CREATE DATABASE  IF NOT EXISTS `model_test` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `model_test`;
-- MySQL dump 10.13  Distrib 5.6.13, for Win32 (x86)
--
-- Host: localhost    Database: model_test
-- ------------------------------------------------------
-- Server version	5.6.14-enterprise-commercial-advanced

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `concept`
--

DROP TABLE IF EXISTS `concept`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `concept` (
  `no` varchar(10) COLLATE utf8_bin NOT NULL,
  `id` varchar(45) CHARACTER SET gbk NOT NULL,
  `name` varchar(45) CHARACTER SET gbk NOT NULL,
  `weight` double NOT NULL,
  PRIMARY KEY (`no`),
  KEY `question_concept_idx` (`id`),
  CONSTRAINT `question_concept` FOREIGN KEY (`id`) REFERENCES `selection` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `concept`
--

LOCK TABLES `concept` WRITE;
/*!40000 ALTER TABLE `concept` DISABLE KEYS */;
INSERT INTO `concept` VALUES ('1-10-1','1-10','进制',1),('1-11-1','1-11','进制',1),('1-12-1','1-12','进制',1),('1-13-1','1-13','进制',1),('1-14-1','1-14','进制',1),('1-2-1','1-2','程序流程结构',1),('1-3-1','1-3','进制',1),('1-4-1','1-4','进制',1),('1-5-1','1-5','进制 ',1),('1-6-1','1-6','进制 ',1),('1-7-1','1-7','进制',1),('1-8-1','1-8','进制',1),('1-9-1','1-9','进制',1),('10-1-1','10-1','程序流程结构',1),('10-2-1','10-2','宏',1),('10-3-1','10-3','宏',0.5),('10-3-2','10-3','程序流程结构',0.5),('10-4-1','10-4','宏',1),('10-5-1','10-5','宏',1),('10-6-1','10-6','字符串',1),('10-7-1','10-7','指针',1),('10-8-1','10-8','宏',1),('10-9-1','10-9','宏',1),('11-1-1','11-1','结构体',1),('11-10-1','11-10','结构体',0.3),('11-10-2','11-10','函数',0.2),('11-10-3','11-10','数据类型',0.2),('11-10-4','11-10','联合体',0.3),('11-11-1','11-11','结构体',0.5),('11-11-2','11-11','指针',0.2),('11-11-3','11-11','数组',0.3),('11-12-1','11-12','结构体',0.5),('11-12-2','11-12','联合体',0.5),('11-13-1','11-13','结构体',0.7),('11-13-2','11-13','数组',0.3),('11-14-1','11-14','结构体',0.8),('11-14-2','11-14','指针',0.2),('11-15-1','11-15','枚举',1),('11-2-1','11-2','结构体',1),('11-3-1','11-3','结构体',1),('11-4-1','11-4','结构体',0.8),('11-4-2','11-4','数据类型',0.2),('11-5-1','11-5','结构体',0.7),('11-5-2','11-5','数组',0.3),('11-7-1','11-7','结构体',0.8),('11-7-2','11-7','指针',0.2),('11-8-1','11-8','结构体',0.9),('11-8-2','11-8','指针',0.1),('11-9-1','11-9','结构体',0.7),('11-9-2','11-9','指针',0.1),('11-9-3','11-9','数组',0.2),('12-1-1','12-1','函数',1),('12-10-1','12-10','函数',0.4),('12-10-2','12-10','文件IO',0.3),('12-10-3','12-10','结构体',0.2),('12-10-4','12-10','指针',0.1),('12-11-1','12-11','函数',1),('12-12-1','12-12','文件IO',1),('12-13-1','12-13','函数',0.4),('12-13-2','12-13','文件IO',0.3),('12-13-3','12-13','字符串',0.2),('12-13-4','12-13','进制',0.1),('12-14-1','12-14','函数',0.7),('12-14-2','12-14','文件IO',0.3),('12-15-1','12-15','函数',0.5),('12-15-2','12-15','文件IO',0.5),('12-16-1','12-16','函数',0.5),('12-16-2','12-16','文件IO',0.4),('12-16-3','12-16','字符串',0.1),('12-17-1','12-17','函数',0.5),('12-17-2','12-17','文件IO',0.3),('12-17-3','12-17','字符串',0.2),('12-18-1','12-18','文件IO',0.8),('12-18-2','12-18','进制',0.2),('12-19-1','12-19','函数',1),('12-2-1','12-2','函数',1),('12-20-1','12-20','函数',1),('12-21-1','12-21','字符串',0.2),('12-21-2','12-21','函数',0.5),('12-21-3','12-21','文件IO',0.3),('12-22-1','12-22','函数',0.7),('12-22-2','12-22','指针',0.3),('12-3-1','12-3','函数',1),('12-4-1','12-4','函数',1),('12-5-1','12-5','函数',1),('12-7-1','12-7','函数',1),('12-8-1','12-8','文件IO',1),('2-1-1','2-1','程序流程结构',1),('2-10-1','2-10','结构体',1),('2-11-1','2-11','结构体',1),('2-12-1','2-12','文件IO',1),('2-13-1','2-13','文件IO',1),('2-14-1','2-14','文件IO',1),('2-15-1','2-15','程序流程结构',1),('2-2-1','2-2',' 程序流程结构',1),('2-3-1','2-3','程序流程结构',0.5),('2-3-2','2-3','函数',0.5),('2-4-1','2-4','程序流程结构',0.5),('2-4-2','2-4','函数',0.5),('2-5-1','2-5','程序流程结构',0.5),('2-5-2','2-5','函数',0.5),('2-6-1','2-6','程序流程结构',1),('2-7-1','2-7','程序流程结构',0.5),('2-7-2','2-7','函数',0.5),('2-8-1','2-8','程序流程结构',1),('2-9-1','2-9','结构体',1),('3-1-1','3-1','数据类型',1),('3-10-1','3-10','数据类型',1),('3-11-1','3-11','数据类型',1),('3-12-1','3-12','数据类型',1),('3-13-1','3-13','数据类型',1),('3-14-1','3-14','数据类型',1),('3-15-1','3-15','数据类型',1),('3-16-1','3-16','数据类型',1),('3-17-1','3-17','数据类型',1),('3-18-1','3-18','程序流程结构',1),('3-19-1','3-19','数据类型',1),('3-2-1','3-2','数据类型',1),('3-20-1','3-20','数据类型',1),('3-21-1','3-21','数据类型',1),('3-22-1','3-22','结构体',1),('3-23-1','3-23','数据类型',1),('3-24-1','3-24','程序流程结构',1),('3-25-1','3-25','函数',1),('3-26-1','3-26','数据类型',1),('3-27-1','3-27','函数',1),('3-28-1','3-28','程序流程结构',1),('3-29-1','3-29','程序流程结构',1),('3-3-1','3-3','数据类型',1),('3-30-1','3-30','程序流程结构',1),('3-4-1','3-4','数据类型',1),('3-5-1','3-5','字符串',1),('3-6-1','3-6','字符串',1),('3-7-1','3-7','程序流程结构',1),('3-8-1','3-8','程序流程结构',1),('3-9-1','3-9','字符串',1),('4-1-1','4-1','程序流程结构',1),('4-10-1','4-10','函数',1),('4-11-1','4-11','函数',1),('4-12-1','4-12','程序流程结构',1),('4-13-1','4-13','程序流程结构',1),('4-14-1','4-14','函数',1),('4-15-1','4-15','程序流程结构',1),('4-2-1','4-2','程序流程结构',1),('4-3-1','4-3','程序流程结构',1),('4-4-1','4-4','程序流程结构',1),('4-5-1','4-5','程序流程结构',1),('4-6-1','4-6','程序流程结构',1),('4-7-1','4-7','数据类型',1),('4-8-1','4-8','程序流程结构',1),('4-9-1','4-9','函数',1),('5-1-1','5-1','函数',1),('5-10-1','5-10','结构体',1),('5-11-1','5-11','结构体',1),('5-12-1','5-12','结构体',1),('5-13-1','5-13','结构体',1),('5-14-1','5-14','函数',1),('5-15-1','5-15','结构体',1),('5-16-1','5-16','结构体',1),('5-17-1','5-17','结构体',1),('5-18-1','5-18','结构体',1),('5-19-1','5-19','结构体',1),('5-2-1','5-2','函数',1),('5-20-1','5-20','结构体',1),('5-21-1','5-21','结构体',1),('5-22-1','5-22','结构体',1),('5-23-1','5-23','结构体',1),('5-24-1','5-24','结构体',1),('5-3-1','5-3','数据类型',1),('5-4-1','5-4','结构体',1),('5-5-1','5-5','结构体',1),('5-6-1','5-6','结构体',1),('5-7-1','5-7','结构体',1),('5-8-1','5-8','结构体',1),('5-9-1','5-9','结构体',1),('6-1-1','6-1','while循环',1),('6-10-1','6-10','while循环',1),('6-11-1','6-11','while循环',1),('6-12-1','6-12','while循环',1),('6-13-1','6-13','while循环',1),('6-14-1','6-14','while循环',1),('6-15-1','6-15','for循环',1),('6-16-1','6-16','while循环',1),('6-17-1','6-17','do-while循环',1),('6-18-1','6-18','do-while循环',1),('6-19-1','6-19','for循环',1),('6-2-1','6-2','for循环',1),('6-20-1','6-20','while循环',1),('6-3-1','6-3','for循环',1),('6-4-1','6-4','for循环',1),('6-6-1','6-6','do-while循环',1),('6-7-1','6-7','while循环',1),('6-8-1','6-8','结构体',1),('6-9-1','6-9','while循环',1),('7-1-1','7-1','数据类型',1),('7-10-1','7-10','数组',1),('7-11-1','7-11','数组',1),('7-12-1','7-12','数组',1),('7-13-1','7-13','数组',1),('7-14-1','7-14','数组',1),('7-15-1','7-15','数组',1),('7-16-1','7-16','数组',1),('7-17-1','7-17','数组',1),('7-18-1','7-18','数组',1),('7-19-1','7-19','数组',1),('7-2-1','7-2','数组',1),('7-20-1','7-20','数组',1),('7-3-1','7-3','数组',1),('7-4-1','7-4','数组',1),('7-5-1','7-5','数组',1),('7-6-1','7-6','数组',1),('7-7-1','7-7','数组',1),('7-8-1','7-8','数组',1),('7-9-1','7-9','数组',1),('8-1-1','8-1','函数',1),('8-10-1','8-10','函数',1),('8-11-1','8-11','函数',1),('8-12-1','8-12','函数',1),('8-13-1','8-13','函数',1),('8-14-1','8-14','函数',1),('8-15-1','8-15','函数',1),('8-16-1','8-16','结构体',1),('8-17-1','8-17','结构体',1),('8-18-1','8-18','结构体',1),('8-19-1','8-19','函数',1),('8-2-1','8-2','函数',1),('8-20-1','8-20','for循环',1),('8-3-1','8-3','函数',1),('8-4-1','8-4','函数',1),('8-5-1','8-5','存储类型',1),('8-6-1','8-6','存储类型',1),('8-7-1','8-7','函数',1),('8-8-1','8-8','函数',1),('8-9-1','8-9','函数',1),('9-1-1','9-1','字符串',1),('9-10-1','9-10','数组',1),('9-11-1','9-11','数组',0.9),('9-11-2','9-11','指针',0.1),('9-12-1','9-12','数组',0.4),('9-12-2','9-12','函数',0.3),('9-12-3','9-12','字符串',0.3),('9-13-1','9-13','函数',1),('9-14-1','9-14','for循环',1),('9-15-1','9-15','程序流程结构',0.6),('9-15-2','9-15','字符串',0.3),('9-15-3','9-15','指针',0.1),('9-16-1','9-16','数组',1),('9-17-1','9-17','函数',1),('9-18-1','9-18','函数',1),('9-19-1','9-19','函数',0.6),('9-19-2','9-19','指针',0.1),('9-19-3','9-19','数据类型',0.3),('9-2-1','9-2','指针',1),('9-20-1','9-20','函数',0.5),('9-20-2','9-20','数据类型',0.5),('9-21-1','9-21','数组',1),('9-22-1','9-22','程序流程结构 ',0.6),('9-22-2','9-22','字符串',0.2),('9-22-3','9-22','存储类别',0.2),('9-23-1','9-23','函数',1),('9-24-1','9-24','函数',0.6),('9-24-2','9-24','指针',0.4),('9-25-1','9-25','程序流程结构',1),('9-3-1','9-3','数据类型',0.3),('9-3-2','9-3','数组',0.3),('9-3-3','9-3','字符串',0.4),('9-4-1','9-4','数组',0.5),('9-4-2','9-4','字符串',0.3),('9-4-3','9-4','指针',0.2),('9-5-1','9-5','指针',0.6),('9-5-2','9-5','函数',0.4),('9-6-1','9-6','指针',1),('9-7-1','9-7','指针',1),('9-8-1','9-8','指针',1),('9-9-1','9-9','指针',1),('﻿1-1-1','1-1','存储类别',1);
/*!40000 ALTER TABLE `concept` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `master`
--

DROP TABLE IF EXISTS `master`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `master` (
  `id` int(11) NOT NULL,
  `no` varchar(10) CHARACTER SET utf8 DEFAULT NULL,
  `time` int(11) DEFAULT NULL,
  `concept` varchar(45) CHARACTER SET utf8 DEFAULT NULL,
  `master` double DEFAULT NULL,
  `feedback` varchar(45) CHARACTER SET utf8 DEFAULT NULL,
  `confidence` double DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `search` (`no`,`time`,`concept`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `master`
--

LOCK TABLES `master` WRITE;
/*!40000 ALTER TABLE `master` DISABLE KEYS */;
INSERT INTO `master` VALUES (1,'10102215',1,'结构体',-1,'完美反映',0.8),(2,'10102215',1,'字符串',0,'有点不准',0),(4,'10102215',2,'ASCII码',0.8,'完美反映',0.8),(5,'10102215',2,'循环体',-1,'基本反映',0.4),(6,'10102215',3,'ASCII码',1,'完美反映',1),(7,'10102215',3,'循环体',0,'完美反映',1),(8,'10102215',3,'八进制',-1,'基本反映',0.4),(9,'10102215',3,'格式控制符',0.2,'基本反映',0.8),(10,'10102215',3,'函数调用',0.2,'完美反映',0.8),(11,'10102215',3,'转义字符',0.6,'基本反映',0.4),(12,'10102215',3,'指针',-0.8148148148148149,'基本反映',0.6000000000000001),(13,'10102215',3,'读文件',0,'有点不准',0.8),(14,'10102215',3,'函数传值',-0.6,'完美反映',0.8),(15,'10102215',3,'结构体',-1,'基本反映',0),(16,'10102215',3,'字符串',-1,'完全瞎搞',0.8),(17,'10102215',4,'ASCII码',-1,'',0.8),(18,'10102215',5,'ASCII码',-1,'',0.4),(19,'10102215',5,'循环体',0,'',1),(20,'10102215',6,'ASCII码',1,'基本反映',1),(21,'10102215',6,'循环体',1,'完美反映',0),(22,'10102215',7,'ASCII码',1,'基本反映',1),(23,'10102215',7,'循环体',-1,'完美反映',0.4),(24,'10102215',8,'ASCII码',1,'完美反映',1),(25,'10102215',8,'循环体',-1,'基本反映',0),(26,'10102215',9,'ASCII码',1,'',1),(27,'10102215',10,'函数',-1,'',0),(28,'10102215',10,'数据类型',0,'',0.30000000000000004),(29,'10102215',10,'程序流程结构',-1,'',1),(30,'10102215',10,'字符串',0,'',0.5),(31,'10102215',10,'结构体',-1,'',0);
/*!40000 ALTER TABLE `master` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `meta_concept`
--

DROP TABLE IF EXISTS `meta_concept`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `meta_concept` (
  `id` int(11) NOT NULL,
  `name` varchar(45) DEFAULT NULL,
  `master` double DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `meta_concept`
--

LOCK TABLES `meta_concept` WRITE;
/*!40000 ALTER TABLE `meta_concept` DISABLE KEYS */;
INSERT INTO `meta_concept` VALUES (1,'数据类型',1),(2,'进制',1),(3,'指针',1),(4,'文件IO',1),(5,'函数',1),(6,'结构体',1),(7,'联合体',1),(8,'for循环',1),(9,'while循环',1),(10,'do-while循环',1),(11,'字符串',1),(12,'控制台IO',1),(13,'宏',1),(14,'链表',1),(15,'枚举',1),(16,'存储类别',1),(17,'数组',1),(18,'程序流程结构',1);
/*!40000 ALTER TABLE `meta_concept` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `options`
--

DROP TABLE IF EXISTS `options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `options` (
  `pk` varchar(45) CHARACTER SET gbk NOT NULL,
  `id` varchar(20) CHARACTER SET gbk NOT NULL,
  `order` int(11) NOT NULL,
  `content` text CHARACTER SET gbk NOT NULL,
  `degree` double NOT NULL,
  PRIMARY KEY (`pk`),
  KEY `quesion_id_idx` (`id`),
  CONSTRAINT `question_option` FOREIGN KEY (`id`) REFERENCES `selection` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `options`
--

LOCK TABLES `options` WRITE;
/*!40000 ALTER TABLE `options` DISABLE KEYS */;
INSERT INTO `options` VALUES ('1-1-1','1-1',1,'程序和指令',-0.5),('1-1-2','1-1',2,'数据和信号',-0.5),('1-1-3','1-1',3,'程序和数据',1),('1-1-4','1-1',4,'ASCII码和数据',-0.5),('1-10-1','1-10',1,'0',1),('1-10-2','1-10',2,'1',-1),('1-10-3','1-10',3,'(FF)16 ',-1),('1-10-4','1-10',4,'(F0)16',0),('1-11-1','1-11',1,'(D7)16',1),('1-11-2','1-11',2,'(28)16 ',0),('1-11-3','1-11',3,'(D8)16',0),('1-11-4','1-11',4,'(27)16',-1),('1-12-1','1-12',1,'(110001)2 ',0),('1-12-2','1-12',2,'(060)8 ',1),('1-12-3','1-12',3,'(60)10',0),('1-12-4','1-12',4,'都不正确',-1),('1-13-1','1-13',1,'与(7F)16按位与',1),('1-13-2','1-13',2,'与(7F)16按位异或 ',0),('1-13-3','1-13',3,'与(80)16按位或',0),('1-13-4','1-13',4,'都不正确',-1),('1-14-1','1-14',1,'与(0F)16按位与 ',0),('1-14-2','1-14',2,'与(F0)16按位异或',1),('1-14-3','1-14',3,'与(0F)16按位异或',0),('1-14-4','1-14',4,'与(0F)16按位或',-1),('1-2-1','1-2',1,'系统软件',1),('1-2-2','1-2',2,'应用软件',0),('1-2-3','1-2',3,'操作系统',0),('1-2-4','1-2',4,'数据库管理系统',-1),('1-3-1','1-3',1,'100011 ',1),('1-3-2','1-3',2,'0100011 ',0),('1-3-3','1-3',3,'100110 ',0),('1-3-4','1-3',4,'100101',-1),('1-4-1','1-4',1,'10B',0),('1-4-2','1-4',2,'10C',1),('1-4-3','1-4',3,'10D',0),('1-4-4','1-4',4,'10E',-1),('1-5-1','1-5',1,'(10100011)2  ',0),('1-5-2','1-5',2,'(FF)16 ',-1),('1-5-3','1-5',3,'(237)8',0),('1-5-4','1-5',4,'789',1),('1-6-1','1-6',1,'(0.2)16',0),('1-6-2','1-6',2,'(0.1)16',0),('1-6-3','1-6',3,'(0.4)16 ',-1),('1-6-4','1-6',4,'(0.8)16',1),('1-7-1','1-7',1,'11011011',1),('1-7-2','1-7',2,'10011011  ',0),('1-7-3','1-7',3,'10110110',0),('1-7-4','1-7',4,'10110111',-1),('1-8-1','1-8',1,'1.0010101 ',0),('1-8-2','1-8',2,'1.0010110',0),('1-8-3','1-8',3,'0.0010110',-1),('1-8-4','1-8',4,'0.1101010',1),('1-9-1','1-9',1,'00010',1),('1-9-2','1-9',2,'100010',0),('1-9-3','1-9',3,'10010',0),('1-9-4','1-9',4,'00011',-1),('10-1-1','10-1',1,'预处理命令行都必须以#号开始',0),('10-1-2','10-1',2,'在程序中凡是以#号开始的语句行都是预处理命令行',0),('10-1-3','10-1',3,'C程序在执行过程中队预处理命令行进行处理',1),('10-1-4','10-1',4,'以下是正确的宏定义 #define IBM_PC',0),('10-2-1','10-2',1,'10',0),('10-2-2','10-2',2,'15',1),('10-2-3','10-2',3,'100',0),('10-2-4','10-2',4,'150',0),('10-3-1','10-3',1,'在程序的一行上可以出现多个有效的预处理命令行',0),('10-3-2','10-3',2,'使用带参的宏时，参数的类型应与宏定义时的一致',0),('10-3-3','10-3',3,'宏替换不占用运行时间，只占编译时间',1),('10-3-4','10-3',4,'在以下定义中C  R是称为“宏名”的标示符 #define C  R  045',0),('10-4-1','10-4',1,'sum=9',0),('10-4-2','10-4',2,'sum=10',1),('10-4-3','10-4',3,'sum=12',0),('10-4-4','10-4',4,'sum=18',0),('10-5-1','10-5',1,'10',0),('10-5-2','10-5',2,'20',0),('10-5-3','10-5',3,'25',1),('10-5-4','10-5',4,'30',0),('10-6-1','10-6',1,'可以把define和if定义为用户标示符',0),('10-6-2','10-6',2,'可以把define定义为用户标示符，但不能把if定义为用户标示符',1),('10-6-3','10-6',3,'可以把if定义为用户标示符，但不能把define定义为用户标示符',0),('10-6-4','10-6',4,'define和if都不能定义为用户标示符',0),('10-7-1','10-7',1,'p是int型变量',0),('10-7-2','10-7',2,'p是基类型为int的指针变量',1),('10-7-3','10-7',3,'q是基类型为int的指针变量  ',0),('10-7-4','10-7',4,'程序中可用INTEGER代替int类型名',0),('10-8-1','10-8',1,'#define POWER(x)  x*x ',0),('10-8-2','10-8',2,'#define POWER(x)  (x)*(x)',0),('10-8-3','10-8',3,'#define POWER(x)  (x*x)',0),('10-8-4','10-8',4,'#define POWER(x)  ((x)*(x))',1),('10-9-1','10-9',1,'7,6',0),('10-9-2','10-9',2,'12,6',0),('10-9-3','10-9',3,'12,5',0),('10-9-4','10-9',4,'7,5',1),('11-1-1','11-1',1,'各成员所需内存量的总和',1),('11-1-2','11-1',2,'结构中第一个成员所需 ',0),('11-1-3','11-1',3,'成员中占内存量最大者所需的容量',0),('11-1-4','11-1',4,'结构中最后一个成员所需内存量',0),('11-10-1','11-10',1,'12',1),('11-10-2','11-10',2,'16',0),('11-10-3','11-10',3,'14',0),('11-10-4','11-10',4,'9',0),('11-11-1','11-11',1,'10',0),('11-11-2','11-11',2,'11',0),('11-11-3','11-11',3,'51',1),('11-11-4','11-11',4,'65',0),('11-12-1','11-12',1,'4',0),('11-12-2','11-12',2,'5',0),('11-12-3','11-12',3,'6',0),('11-12-4','11-12',4,'0',1),('11-13-1','11-13',1,'1,2',0),('11-13-2','11-13',2,'2,3',0),('11-13-3','11-13',3,'1,4',0),('11-13-4','11-13',4,'3,2',1),('11-14-1','11-14',1,'10',0),('11-14-2','11-14',2,'20',0),('11-14-3','11-14',3,'30',0),('11-14-4','11-14',4,'40',1),('11-15-1','11-15',1,'5',1),('11-15-2','11-15',2,'3',0),('11-15-3','11-15',3,'4',0),('11-15-4','11-15',4,'编译错',0),('11-2-1','11-2',1,'struct是结构体类型的关键字',0),('11-2-2','11-2',2,'struc stu是用户定义的结构体类型',0),('11-2-3','11-2',3,'stutype是用户定义的结构体类型名',1),('11-2-4','11-2',4,'a和b都是结构体成员名',0),('11-3-1','11-3',1,'所有成员一直驻留在内存中',1),('11-3-2','11-3',2,'只有一个成员驻留在内存中',0),('11-3-3','11-3',3,'部分成员驻留在内存中',0),('11-3-4','11-3',4,'没有成员驻留在内存中',0),('11-4-1','11-4',1,'1',0),('11-4-2','11-4',2,'2',0),('11-4-3','11-4',3,'8',0),('11-4-4','11-4',4,'11',1),('11-5-1','11-5',1,'printf(“%c\\n”, class[3].name);',0),('11-5-2','11-5',2,'printf(“%c\\n”, class[3].name[1]);',0),('11-5-3','11-5',3,'printf(“%c\\n”, class[2].name);',0),('11-5-4','11-5',4,'printf(“%c\\n”, class[2].name[0]);',1),('11-7-1','11-7',1,'p = &a;',0),('11-7-2','11-7',2,'p = data,a; ',0),('11-7-3','11-7',3,'&data,a',1),('11-7-4','11-7',4,'*p = data,a;',0),('11-8-1','11-8',1,'p.next = q;',0),('11-8-2','11-8',2,'p.next=&b;',1),('11-8-3','11-8',3,' p ->next=&b;',0),('11-8-4','11-8',4,' (*p).next=q;',0),('11-9-1','11-9',1,'260.00',0),('11-9-2','11-9',2,'270.00',1),('11-9-3','11-9',3,'280.00',0),('11-9-4','11-9',4,'285.00',0),('12-1-1','12-1',1,'fscanf (fp, 格式字符串，输出表列)；',0),('12-1-2','12-1',2,'fscanf (格式字符串，输出表列，fp)；',0),('12-1-3','12-1',3,'fscanf (格式字符串，文件指针，输出表列)；',0),('12-1-4','12-1',4,'fscanf (文件指针，格式字符串，输出表列)；',1),('12-10-1','12-10',1,'地址值  ',0),('12-10-2','12-10',2,'0',1),('12-10-3','12-10',3,'1',0),('12-10-4','12-10',4,'EOF',0),('12-11-1','12-11',1,'-1',0),('12-11-2','12-11',2,'TRUE',0),('12-11-3','12-11',3,'0',1),('12-11-4','12-11',4,'1',0),('12-12-1','12-12',1,'文件打开时，原有文件内容不被删除，位置指针移到文件末尾，可进行添加和读操作',1),('12-12-2','12-12',2,'文件打开时，原有文件内容不被删除，位置指针移到文件开头，可进行重写和读写操作',0),('12-12-3','12-12',3,'文件打开时，原有文件内容被删除，可进行写操作',0),('12-12-4','12-12',4,'以上各种说法皆不正确',0),('12-13-1','12-13',1,'“ab++” ',0),('12-13-2','12-13',2,'“wb+”',1),('12-13-3','12-13',3,'“rb+”',0),('12-13-4','12-13',4,'“ab”',0),('12-14-1','12-14',1,'只写',0),('12-14-2','12-14',2,'追加 ',0),('12-14-3','12-14',3,'读或者读写',0),('12-14-4','12-14',4,'答案B和C都正确',1),('12-15-1','12-15',1,'EOF ',0),('12-15-2','12-15',2,'0',0),('12-15-3','12-15',3,'非零值',1),('12-15-4','12-15',4,'NULL',0),('12-16-1','12-16',1,'fopen(“A:\\user\\abc.txt”,”r”)',0),('12-16-2','12-16',2,'fopen(“A:\\\\user\\\\abc.txt”,”r+”)        ',1),('12-16-3','12-16',3,'fopen(“A:\\user\\abc.txt”,”rb”)   ',0),('12-16-4','12-16',4,' fopen(“A:\\\\user\\\\abc.txt”,”w”)',0),('12-17-1','12-17',1,'hello,',1),('12-17-2','12-17',2,'new worldhello,',0),('12-17-3','12-17',3,'new world',0),('12-17-4','12-17',4,'hello,rld',0),('12-18-1','12-18',1,'二进制文件打开后可以先读文件的末尾，而顺序文件不可以  ',1),('12-18-2','12-18',2,'在程序结束时，应当用fclose函数关闭已打开的文件',0),('12-18-3','12-18',3,'在利用fread函数从二进制文件中读数据时，可以用数组名给数组中所有元素读入数据',0),('12-18-4','12-18',4,'不可以用FILE定义指向二进制文件的文件指针',0),('12-19-1','12-19',1,'得到流式文件中的当前位置 ',1),('12-19-2','12-19',2,'移到流式文件的位置指针',0),('12-19-3','12-19',3,'初始化流式文件的位置指针',0),('12-19-4','12-19',4,'以上答案均正确',0),('12-2-1','12-2',1,'使位置指针重新返回文件的开头',1),('12-2-2','12-2',2,'将位置指针指向文件中所要求的特定位置',0),('12-2-3','12-2',3,'使位置指针指向文件的末尾',0),('12-2-4','12-2',4,'使位置指针自动移至下一个字符位置',0),('12-20-1','12-20',1,'fprintf函数 ',0),('12-20-2','12-20',2,' fread函数 ',0),('12-20-3','12-20',3,' fwrite函数  ',1),('12-20-4','12-20',4,' fputc函数',0),('12-21-1','12-21',1,'20,30',1),('12-21-2','12-21',2,'20,50',0),('12-21-3','12-21',3,'30,50',0),('12-21-4','12-21',4,'30,20',0),('12-22-1','12-22',1,'一个整数，代表要读入的数据项总数',0),('12-22-2','12-22',2,'一个文件指针，指向要读的文件',0),('12-22-3','12-22',3,' 一个指针，指向要读入数据的存放地址',1),('12-22-4','12-22',4,'一个存储区，存放要读的数据项',0),('12-3-1','12-3',1,'fseek(文件类型指针，起始点，位移量)',0),('12-3-2','12-3',2,'fseek(fp，位移量，起始点)',1),('12-3-3','12-3',3,'fseek(位移量，起始点，fp)',0),('12-3-4','12-3',4,'fseek(起始点，位移量，文件类型指针)',0),('12-4-1','12-4',1,'改变文件的位置指针        ',0),('12-4-2','12-4',2,'文件的顺序读写',0),('12-4-3','12-4',3,'文件的随机读写     ',0),('12-4-4','12-4',4,'以上答案均正确',1),('12-5-1','12-5',1,'将文件位置指针移到距离文件头20个字节处',0),('12-5-2','12-5',2,'将文件位置指针从当前位置向后移动20个字节',0),('12-5-3','12-5',3,'将文件位置指针从文件末尾处退后20个字节',1),('12-5-4','12-5',4,'将文件位置指针移到离当前位置20个字节处',0),('12-7-1','12-7',1,'EOF ',0),('12-7-2','12-7',2,'1',0),('12-7-3','12-7',3,'0',0),('12-7-4','12-7',4,'输出的字符',1),('12-8-1','12-8',1,'键盘',1),('12-8-2','12-8',2,'显示器',0),('12-8-3','12-8',3,'软盘 ',0),('12-8-4','12-8',4,'硬盘',0),('2-1-1','2-1',1,'机器语言',0),('2-1-2','2-1',2,'低级语言',0),('2-1-3','2-1',3,'中级语言 ',-1),('2-1-4','2-1',4,'高级语言 ',1),('2-10-1','2-10',1,' 由“/*”开头，“*/”结尾 ',1),('2-10-2','2-10',2,'由“/*”开头，“/*”结尾',0),('2-10-3','2-10',3,'由“//”开头  ',0),('2-10-4','2-10',4,'由“/*”或者“//”开头',-1),('2-11-1','2-11',1,'“.”',-1),('2-11-2','2-11',2,'“；”',1),('2-11-3','2-11',3,'“，”',0),('2-11-4','2-11',4,'都不是',0),('2-12-1','2-12',1,' .c  ',1),('2-12-2','2-12',2,'.cpp',0),('2-12-3','2-12',3,'.obj',0),('2-12-4','2-12',4,'.exe',-1),('2-13-1','2-13',1,'.c',0),('2-13-2','2-13',2,'.obj',1),('2-13-3','2-13',3,'.exe',0),('2-13-4','2-13',4,'.cpp',-1),('2-14-1','2-14',1,'.c',0),('2-14-2','2-14',2,'.obj',0),('2-14-3','2-14',3,'.exe',1),('2-14-4','2-14',4,'.cpp',-1),('2-15-1','2-15',1,'检查C程序的语法错误',1),('2-15-2','2-15',2,'检查C程序的逻辑错误',0),('2-15-3','2-15',3,'检查程序的完整性',0),('2-15-4','2-15',4,'生成目标文件',-1),('2-2-1','2-2',1,'适应性',0),('2-2-2','2-2',2,'移植性',1),('2-2-3','2-2',3,'兼容性',0),('2-2-4','2-2',4,'操作性',-1),('2-3-1','2-3',1,'一个主程序和若干子程序组成',0),('2-3-2','2-3',2,'函数组成',1),('2-3-3','2-3',3,'若干过程组成',0),('2-3-4','2-3',4,'若干子程序组成',-1),('2-4-1','2-4',1,'必须在最开始',0.5),('2-4-2','2-4',2,'必须在系统调用的库函数的后面',0),('2-4-3','2-4',3,'可以任意',1),('2-4-4','2-4',4,'必须在最后',-1),('2-5-1','2-5',1,'程序中的第一条可执行语句',0),('2-5-2','2-5',2,'程序中的第一个函数',0),('2-5-3','2-5',3,'main函数',1),('2-5-4','2-5',4,'包含文件中的第一个函数',-1),('2-6-1','2-6',1,'C语言程序书写时，不区分大小写字母',-1),('2-6-2','2-6',2,'C语言程序书写时，一行只能写一个语句',-1),('2-6-3','2-6',3,'C语言程序书写时，一个语句可分成几行书写',1),('2-6-4','2-6',4,'C语言程序书写时每行必须有行号',0),('2-7-1','2-7',1,'一个C语言源程序可由一个或者多个函数组成',-1),('2-7-2','2-7',2,'一个C语言源程序必须包含一个main函数',-1),('2-7-3','2-7',3,'C语言程序的基本组成单位是函数',0),('2-7-4','2-7',4,'在C语言程序中，注释说明只能位于一条语句的后面',1),('2-8-1','2-8',1,' C语言兼有高级语言和低级语言的双重特点，执行效率高',0),('2-8-2','2-8',2,' C语言既可以用来编写应用程序，又可以用来编写系统软件',0),('2-8-3','2-8',3,'C语言的可移植性较差',1),('2-8-4','2-8',4,'C语言是一种结构式模块化程序设计语言',-1),('2-9-1','2-9',1,' 程序行 ',0),('2-9-2','2-9',2,'语句',0),('2-9-3','2-9',3,'函数',-1),('2-9-4','2-9',4,'字符',1),('3-1-1','3-1',1,'8,2,4,1',0),('3-1-2','3-1',2,'2,8,4,1 ',0),('3-1-3','3-1',3,'4,2,8,1',-1),('3-1-4','3-1',4,'4,2,8,1',1),('3-10-1','3-10',1,'包含1个字符',1),('3-10-2','3-10',2,'包含2个字符',0),('3-10-3','3-10',3,'包含3个字符',0),('3-10-4','3-10',4,'说明不合法，c的值不确定',-1),('3-11-1','3-11',1,'2.500000  ',1),('3-11-2','3-11',2,'2.750000  ',0),('3-11-3','3-11',3,'3.500000  ',0),('3-11-4','3-11',4,'0.000000  ',-1),('3-12-1','3-12',1,'int',-1),('3-12-2','3-12',2,'float',0),('3-12-3','3-12',3,'double',1),('3-12-4','3-12',4,'不确定',0),('3-13-1','3-13',1,'一个双精度型表达式 ',-1),('3-13-2','3-13',2,'整型表达式',1),('3-13-3','3-13',3,'一种函数调用 ',0),('3-13-4','3-13',4,'一种不合法的表达式',0),('3-14-1','3-14',1,' n=(n*100+0.5)/100.0',-1),('3-14-2','3-14',2,' m=n*100+0.5，n=m/100.0  ',1),('3-14-3','3-14',3,'n=n*100+0.5/100.0',0),('3-14-4','3-14',4,'n=(n/100+0.5)*100.0',0),('3-15-1','3-15',1,'/',0),('3-15-2','3-15',2,'++',-1),('3-15-3','3-15',3,'！=',0),('3-15-4','3-15',4,'%',1),('3-16-1','3-16',1,'a:=b+1',-1),('3-16-2','3-16',2,'a=b=c+2',1),('3-16-3','3-16',3,'int 18.5%3 ',-1),('3-16-4','3-16',4,'a=a+7=c+b',0),('3-17-1','3-17',1,'x%=(k%=5)',-1),('3-17-2','3-17',2,' x%=(k-k%=5) ',0),('3-17-3','3-17',3,'x%=k-k%=5',0),('3-17-4','3-17',4,'(x%=k)-(k%=5)',1),('3-18-1','3-18',1,' a==1',-1),('3-18-2','3-18',2,' ++i；',1),('3-18-3','3-18',3,'a=a++=5;',0),('3-18-4','3-18',4,'a=int(i);',0),('3-19-1','3-19',1,'34',-1),('3-19-2','3-19',2,'42',-1),('3-19-3','3-19',3,'43',0),('3-19-4','3-19',4,'33',1),('3-2-1','3-2',1,'A P_0 do',0),('3-2-2','3-2',2,'float la0 _A ',0),('3-2-3','3-2',3,'b-a sizeof int',1),('3-2-4','3-2',4,'_123 temp int',-1),('3-20-1','3-20',1,'\'\'c\'\' ',-1),('3-20-2','3-20',2,'\'\'//\' ',-1),('3-20-3','3-20',3,'\'w\'',1),('3-20-4','3-20',4,'\'\'',0),('3-21-1','3-21',1,'char<int<long int<=float<double',1),('3-21-2','3-21',2,'char=int<long int<=float<double',-1),('3-21-3','3-21',3,' char<int<long int=float=double ',0),('3-21-4','3-21',4,'char=int=long int<=float<double',0),('3-22-1','3-22',1,'2',-1),('3-22-2','3-22',2,'7',0),('3-22-3','3-22',3,'8',1),('3-22-4','3-22',4,'在C语言程序中，每行中只能写一条语句',-1),('3-23-1','3-23',1,'6',-1),('3-23-2','3-23',2,'若a是实型变量，C语言程序中允许赋值a=10，因此实型变量中允许存放整型数  ',-1),('3-23-3','3-23',3,'在C语言程序中，无论是整数还是实数，都能被准确无误地表示',0),('3-23-4','3-23',4,'在C语言程序中，%是只能用于整数运算的运算符',1),('3-24-1','3-24',1,'3.500000 ',-1),('3-24-2','3-24',2,'3',0),('3-24-3','3-24',3,'2.000000 ',-1),('3-24-4','3-24',4,'3.000000 ',1),('3-25-1','3-25',1,'-6',-1),('3-25-2','3-25',2,'12',0),('3-25-3','3-25',3,'0',-1),('3-25-4','3-25',4,'-12',1),('3-26-1','3-26',1,'a=20000+20000;',0),('3-26-2','3-26',2,'a=4000*10;',-1),('3-26-3','3-26',3,' a=30000+10000',0),('3-26-4','3-26',4,' a=4000L*10L;',1),('3-27-1','3-27',1,'a的值是字符C ',-1),('3-27-2','3-27',2,' a的值是浮点型 ',0),('3-27-3','3-27',3,'不允许字符型和浮点型相加',0),('3-27-4','3-27',4,'a的值是字符\'A\'的ASCII值加上1',1),('3-28-1','3-28',1,'a\\bre\\\'hi\\\'y\\\\\\bou',-1),('3-28-2','3-28',2,'a\\bre\\\'hi\\\'\'y\\bou',-1),('3-28-3','3-28',3,'re\'hi\\\'you ',1),('3-28-4','3-28',4,'abre\'hi\'y\\bou',0),('3-29-1','3-29',1,'-32767 ',0),('3-29-2','3-29',2,'FFFE',0),('3-29-3','3-29',3,'-1',1),('3-29-4','3-29',4,'-32768',-1),('3-3-1','3-3',1,'160   —0xffff   011',1),('3-3-2','3-3',2,'—0xcdf 01a 0xe',0),('3-3-3','3-3',3,'—01   986,012   0668',0),('3-3-4','3-3',4,'—0x48a 2e5 0x',-1),('3-30-1','3-30',1,'1',0),('3-30-2','3-30',2,'0',1),('3-30-3','3-30',3,'-1',0),('3-30-4','3-30',4,'2',-1),('3-4-1','3-4',1,' 160   0.12   e3',-1),('3-4-2','3-4',2,'123 2e4.2 .e5',1),('3-4-3','3-4',3,'—.18  123e4  0.0 ',0),('3-4-4','3-4',4,'—e3  .234  1e3',0),('3-5-1','3-5',1,' \'\\\'\'\'  \'\\\\\' \'\\xf\' ',0),('3-5-2','3-5',2,' \'\\1011\'  \'\\\'  \'\\ab\'',1),('3-5-3','3-5',3,'\'\\011\'  \'\\f\'  \'\\}\'',-1),('3-5-4','3-5',4,'\'\\abc\'  \'\\101\'  \'xlf\'',-1),('3-6-1','3-6',1,'0.0  0f  8.9e  \'&\'',-1),('3-6-2','3-6',2,'\'\'a\'\'  3.9e-2.5 1e1  \'\\\'\'\'',0),('3-6-3','3-6',3,'\'3\'  011  0xff00  0a',0),('3-6-4','3-6',4,'1+001  0xabcd  2e2  50',1),('3-7-1','3-7',1,'中0f、8.9e是非法的数值常量',0),('3-7-2','3-7',2,'中\'\'a\'\'是字符串常量，是非法的数值常量或者字符常量',0),('3-7-3','3-7',3,'中0a是非法的数值常量',-1),('3-7-4','3-7',4,'中均是合法的数值常量',1),('3-8-1','3-8',1,'24.8',-1),('3-8-2','3-8',2,'21.8',1),('3-8-3','3-8',3,'21.7',0),('3-8-4','3-8',4,'24.7',0),('3-9-1','3-9',1,'32769',0),('3-9-2','3-9',2,'32767',0),('3-9-3','3-9',3,' -32767',1),('3-9-4','3-9',4,'输出不确定的数',-1),('4-1-1','4-1',1,' 32769 ',0),('4-1-2','4-1',2,'8U',1),('4-1-3','4-1',3,'32767',-1),('4-1-4','4-1',4,'-32767',0),('4-10-1','4-10',1,'\'1\'、\'2\'、\'3\'',0),('4-10-2','4-10',2,'\'1\'、\' \'、\'2\'',1),('4-10-3','4-10',3,'\'1\'、\'2\'、\' \'',0),('4-10-4','4-10',4,'\'1\'、\' \'、\'3\'',-1),('4-11-1','4-11',1,'scanf (”%d,%1x,%1e”, &x, &y, &z);',0),('4-11-2','4-11',2,'scanf (”%2d*%d%1f”, &x, &y, &z);',0),('4-11-3','4-11',3,'scanf (”%x%*d%o”, &x, &y); ',0),('4-11-4','4-11',4,'scanf (”%x%o%6.2f”, &x, &y, &z);',1),('4-12-1','4-12',1,'10A□20□B↙',-1),('4-12-2','4-12',2,'10□A□20□B↙',-1),('4-12-3','4-12',3,'10A20B↙',1),('4-12-4','4-12',4,'10A20□B↙',0),('4-13-1','4-13',1,'x+y+z=48',0),('4-13-2','4-13',2,'x+y+z=38',-1),('4-13-3','4-13',3,'x+y+z=35',-1),('4-13-4','4-13',4,'无法确定',1),('4-14-1','4-14',1,' 12345   678.000000',0),('4-14-2','4-14',2,'123   678.000000',-0.5),('4-14-3','4-14',3,'123   45.678000',-0.5),('4-14-4','4-14',4,'123   45.000000',1),('4-15-1','4-15',1,'2，345，1，a',1),('4-15-2','4-15',2,'12，345，a，b',-0.5),('4-15-3','4-15',3,'2a，45b，1，3',0),('4-15-4','4-15',4,'2，789，1，a',-0.5),('4-2-1','4-2',1,'|-0003366|',-1),('4-2-2','4-2',2,'|00003366|',0),('4-2-3','4-2',3,'|3366□□□□|',1),('4-2-4','4-2',4,'输出格式非法',-1),('4-3-1','4-3',1,'s1 = | chinabeijing □□□|   s2 = |chi|',-1),('4-3-2','4-3',2,'s1 = | chinabeijing □□□|   s2 = |chi□□|',0),('4-3-3','4-3',3,'s1 = | □□□ chinabeijing|   s2 = |□□chi|',0),('4-3-4','4-3',4,'s1 = | □□□ chinabeijing|   s2 = |chi□□|',1),('4-4-1','4-4',1,'y = |□□-43456|   y = |-□□43456|   y = |-0043456|   y = |-43456□□|',0),('4-4-2','4-4',2,'y = |□□-43456|   y = |-43456□□|   y = |-0043456|   y = |-□□43456| ',0),('4-4-3','4-4',3,'y = |-43456□□|   y = |-43456□□|   y = |-0043456|   y = |□□-43456| ',1),('4-4-4','4-4',4,' y = |-43456□□|   y = |-4345600|   y = |-0043456|   y = |□□-43456|',-1),('4-5-1','4-5',1,'y = |2456|   y = |□□□□2456|   y = |□□□02456|   y = |00002456|',0),('4-5-2','4-5',2,' y = |4630|   y = |□□□□4630|   y = |□□□04630|   y = |00004630|',1),('4-5-3','4-5',3,' y = |2456|   y = |□□□□2456|   y = |###02456|   y = |00002456|',0),('4-5-4','4-5',4,' y = |4630|   y = |□□□□4630|   y = |###04630|   y = |00004630|',0),('4-6-1','4-6',1,'scanf (”%f%f, &a, &b);',-1),('4-6-2','4-6',2,'scanf (”%f%d, &a, &b);',-1),('4-6-3','4-6',3,'scanf (”%d,%f, &a, &b);',1),('4-6-4','4-6',4,' scanf (”%6.2f%6.2f, &a, &b);',0),('4-7-1','4-7',1,'空格 ',-0.5),('4-7-2','4-7',2,'Tab键',-1),('4-7-3','4-7',3,'回车',-1),('4-7-4','4-7',4,'逗号',1),('4-8-1','4-8',1,'25□2.5',-1),('4-8-2','4-8',2,'25,2.5',-1),('4-8-3','4-8',3,'a =25, b =2.5',1),('4-8-4','4-8',4,' a =25□b =2.5',0),('4-9-1','4-9',1,'scanf (”%*3d%3c%3d”, &a, &b);',-1),('4-9-2','4-9',2,'scanf (”%3d%*3c%3d”, &a, &b);',1),('4-9-3','4-9',3,'scanf (”%3d%3c%*3d”, &a, &b);',-1),('4-9-4','4-9',4,'scanf (”%3d%*2d%3d”, &a, &b);',-0.5),('5-1-1','5-1',1,'if (x>0) y = 1;  else if (x<0) y=-1 else y=0;',1),('5-1-2','5-1',2,'if (x) if (x>0) y=1; else if (x>0) y=-1;',-0.5),('5-1-3','5-1',3,'y = -1 if (x) if (x>0) y = 1; else if (x==0) y=0; else  y = -1;',-0.5),('5-1-4','5-1',4,'y =0 if (x>=0) if (x>0) y = 1; else  y = -1;',-0.5),('5-10-1','5-10',1,'0.000000',-0.5),('5-10-2','5-10',2,'0.250000',-0.5),('5-10-3','5-10',3,'0.500000',1),('5-10-4','5-10',4,'1.000000',-0.5),('5-11-1','5-11',1,'if（x>y）z=x;',-0.5),('5-11-2','5-11',2,'if (x==y) z=0;',-0.5),('5-11-3','5-11',3,'if(x!=y) z=0;printf(“%d”,x); z=0;else z=0;printf(“%d”,y);',1),('5-11-4','5-11',4,'if (x<y) { x++;y--; }',-0.5),('5-12-1','5-12',1,'a= 20 , b = 30 , c = 20',1),('5-12-2','5-12',2,'a = 20, b = 40, c = 20',-0.5),('5-12-3','5-12',3,'a = 30, b = 40 , c = 20',-0.5),('5-12-4','5-12',4,'a = 30 , b = 40 , c =30',-0.5),('5-13-1','5-13',1,'k= = 0',-0.5),('5-13-2','5-13',2,'k = = 1',-0.5),('5-13-3','5-13',3,'K!=0',1),('5-13-4','5-13',4,'K!=1',-0.5),('5-14-1','5-14',1,'LOW ',1),('5-14-2','5-14',2,'UP',-0.5),('5-14-3','5-14',3,'LOWUP',-0.5),('5-14-4','5-14',4,'程序语法错误',-0.5),('5-15-1','5-15',1,'有语法错误不能通过编译',1),('5-15-2','5-15',2,'若输入4,5则输出5,6',-0.5),('5-15-3','5-15',3,'若输入5,4则输出4,5',-0.5),('5-15-4','5-15',4,'若输入5,4则输出5,5',-0.5),('5-16-1','5-16',1,'x=10,y=20,z=30',-0.5),('5-16-2','5-16',2,'x=20,y=30,z=30',1),('5-16-3','5-16',3,'x=20,y=30,z=10',-0.5),('5-16-4','5-16',4,'x=20,y=30,z=20',-0.5),('5-17-1','5-17',1,'有语法错不能通过编辑',-0.5),('5-17-2','5-17',2,'可以通过编译但不能通过连接',-0.5),('5-17-3','5-17',3,'输出*** ',-0.5),('5-17-4','5-17',4,'输出$$$',1),('5-18-1','5-18',1,'YES',1),('5-18-2','5-18',2,'NO',-0.5),('5-18-3','5-18',3,'YESNO',-0.5),('5-18-4','5-18',4,'语法错误',-0.5),('5-19-1','5-19',1,'1',-0.5),('5-19-2','5-19',2,'2',1),('5-19-3','5-19',3,'3',-0.5),('5-19-4','5-19',4,'6',-0.5),('5-2-1','5-2',1,'缩排位置相同的if',-0.5),('5-2-2','5-2',2,'其上最近的if ',-0.5),('5-2-3','5-2',3,'下面最近的if',-0.5),('5-2-4','5-2',4,'其上最近的未配对的if',1),('5-20-1','5-20',1,'0',-0.5),('5-20-2','5-20',2,'语法错',-0.5),('5-20-3','5-20',3,'1 ',1),('5-20-4','5-20',4,'“假”',-0.5),('5-21-1','5-21',1,'1',1),('5-21-2','5-21',2,'2',-0.5),('5-21-3','5-21',3,'3',-0.5),('5-21-4','5-21',4,'4',-0.5),('5-22-1','5-22',1,'3',-0.5),('5-22-2','5-22',2,'4',1),('5-22-3','5-22',3,'5',-0.5),('5-22-4','5-22',4,'6',-0.5),('5-23-1','5-23',1,'switch (a+b) { case 1 : y = a+b ; break ;&nbsp;&nbsp;&nbsp;&nbsp;case0 : y = a- b ; break; case 3 : y = b-a; break; }',1),('5-23-2','5-23',2,'switch (a+b) { case 3; case 1 : y = a+b ; break; }',-0.5),('5-23-3','5-23',3,'switch (a)  { case 1: y = a-b ; break ; case 2: y = a*b ; break ; default: x=a+b; }',-0.5),('5-23-4','5-23',4,'switch (a-b){  default: y=a*b;break; case 3 :  case4: x = a+b ; case10 :  case11 : y=a-b;break; }',-0.5),('5-24-1','5-24',1,'必须是关系表达式',-0.5),('5-24-2','5-24',2,'须是关系表达式或者逻辑表达式',-0.5),('5-24-3','5-24',3,'须是关系表达式或者算数表达式',-0.5),('5-24-4','5-24',4,'可以是任意表达式',1),('5-3-1','5-3',1,'只能是0或者1',-0.5),('5-3-2','5-3',2,'只能是0或者非0正数',-0.5),('5-3-3','5-3',3,'只能是整型或者字符型数据',-0.5),('5-3-4','5-3',4,'可以是任何类型的数据',1),('5-4-1','5-4',1,'关系运算符<算术运算符<赋值运算符<逻辑运算符',-0.5),('5-4-2','5-4',2,'逻辑运算符<关系运算符<算术运算符<赋值运算符',-0.5),('5-4-3','5-4',3,'赋值运算符<逻辑运算符<关系运算符<算术运算符',1),('5-4-4','5-4',4,'算术运算符<关系运算符<赋值运算符<逻辑运算符',-0.5),('5-5-1','5-5',1,'<',-0.5),('5-5-2','5-5',2,'+',1),('5-5-3','5-5',3,'&& ',-0.5),('5-5-4','5-5',4,'！=',-0.5),('5-6-1','5-6',1,'A%2==1 ',-0.5),('5-6-2','5-6',2,'!(A%2==0)',-0.5),('5-6-3','5-6',3,'!(A%2)',1),('5-6-4','5-6',4,'A%2',-0.5),('5-7-1','5-7',1,'‘a’<=c1<‘z’ ',-0.5),('5-7-2','5-7',2,'(c1>=a)&&(c1<=z)',-0.5),('5-7-3','5-7',3,'(‘a’>=c1)||(‘z’<=c1)',-0.5),('5-7-4','5-7',4,'(c1>=’a’)&&(c1<=’z’)',1),('5-8-1','5-8',1,'switch (w){case 1.0 : printf (“*\\n”); case 2.0 : printf (“**\\n”);}',-0.5),('5-8-2','5-8',2,'switch (a){case 1 : printf(“*\\n”); case 2 : printf(“**\\n”);}',1),('5-8-3','5-8',3,'switch (b){ case 1 : printf  (“*\\n”); default: printf  (“\\n”); case a : printf  (“**\\n”); }',-0.5),('5-8-4','5-8',4,'switch (a + b);{ case 1 : printf (“*\\n”); case 2 : printf  (“**\\n”); default: printf“\\n”); }',-0.5),('5-9-1','5-9',1,'a=2,b=1',1),('5-9-2','5-9',2,'a=1,b=1',-0.5),('5-9-3','5-9',3,'a=1,b=0',-0.5),('5-9-4','5-9',4,'a=2,b=2',-0.5),('6-1-1','6-1',1,'E==0 ',1),('6-1-2','6-1',2,'E! = 1',-0.5),('6-1-3','6-1',3,'E!= 0',-0.5),('6-1-4','6-1',4,'E = = 1',-0.5),('6-10-1','6-10',1,'while 循环执行10次 ',-0.5),('6-10-2','6-10',2,'循环是无限循环',-0.5),('6-10-3','6-10',3,'循环体语句一次也不执行',1),('6-10-4','6-10',4,'循环体语句执行一次',-0.5),('6-11-1','6-11',1,'运行程序段后输出0',-0.5),('6-11-2','6-11',2,'运行程序段后输出1',1),('6-11-3','6-11',3,'程序段中的控制表达式是非法的',-0.5),('6-11-4','6-11',4,'程序段执行无限次',-0.5),('6-12-1','6-12',1,'1,2,0 ',1),('6-12-2','6-12',2,'2,1,0',-0.5),('6-12-3','6-12',3,'1,2,1',-0.5),('6-12-4','6-12',4,'2,1,1',-0.5),('6-13-1','6-13',1,'20,7 ',-0.5),('6-13-2','6-13',2,'6,12',-0.5),('6-13-3','6-13',3,'20,8',-0.5),('6-13-4','6-13',4,'8,20',1),('6-14-1','6-14',1,'是死循环',-0.5),('6-14-2','6-14',2,'循环执行二次',-0.5),('6-14-3','6-14',3,'循环执行一次',1),('6-14-4','6-14',4,'有语法错误',-0.5),('6-15-1','6-15',1,'是无限循环',-0.5),('6-15-2','6-15',2,'循环次数不定 ',-0.5),('6-15-3','6-15',3,'4次',1),('6-15-4','6-15',4,'3次',-0.5),('6-16-1','6-16',1,'其中循环控制表达式与0等价',-0.5),('6-16-2','6-16',2,'其中循环控制表达式与‘0’等价',1),('6-16-3','6-16',3,'其中循环控制表达式是不合法的',-0.5),('6-16-4','6-16',4,'以上说法都不对',-0.5),('6-17-1','6-17',1,'由于do-while循环中循环体语句只能是一条可执行语句，所以循环体内不能使用复合语句',-0.5),('6-17-2','6-17',2,'do-while循环由do开始，用while结束，在while（表达式）后面不能写分号',-0.5),('6-17-3','6-17',3,'在do-while循环体中，一定要有能使while后面表达式的值变为零（“假”）的操作',1),('6-17-4','6-17',4,'do-while循环中，根据情况可以省略while',-0.5),('6-18-1','6-18',1,'P的值不等于12345并且n的值小于3',-0.5),('6-18-2','6-18',2,'P的值等于12345并且n的值大于等于3',-0.5),('6-18-3','6-18',3,'P的值不等于12345或者n的值小于3',-0.5),('6-18-4','6-18',4,'P的值等于12345或者n的值大于等于3',1),('6-19-1','6-19',1,'101',-0.5),('6-19-2','6-19',2,'6',-0.5),('6-19-3','6-19',3,'5',-0.5),('6-19-4','6-19',4,'4',1),('6-2-1','6-2',1,'for（表达式1；0；表达式3）',-0.5),('6-2-2','6-2',2,'for（表达式1；1；表达式3）',1),('6-2-3','6-2',3,'for（表达式1；表达式1；表达式3）',-0.5),('6-2-4','6-2',4,'for（表达式1；表达式3；表达式3）',-0.5),('6-20-1','6-20',1,'1',-0.5),('6-20-2','6-20',2,'10',-0.5),('6-20-3','6-20',3,'6',-0.5),('6-20-4','6-20',4,'死循环，不能确定次数。',1),('6-3-1','6-3',1,'for(y=0,x=1;x>++y;x=i++) i=x;',1),('6-3-2','6-3',2,'for(;;x++=i);',-0.5),('6-3-3','6-3',3,'while (1){x++;}',-0.5),('6-3-4','6-3',4,'for(i=10;;i- -)  sum +=I;',-0.5),('6-4-1','6-4',1,'for循环只能用于循环次数已经确定的情况',-0.5),('6-4-2','6-4',2,'for循环是先执行循环体语句，后判断表达式',-0.5),('6-4-3','6-4',3,'在for循环中，不能用break语句跳出循环体',-0.5),('6-4-4','6-4',4,'for循环的循环体语句中，可以包含多条语句，但必须用花括号括起来',1),('6-6-1','6-6',1,'无限次 ',-0.5),('6-6-2','6-6',2,'0次',-0.5),('6-6-3','6-6',3,'1次',-0.5),('6-6-4','6-6',4,'2次',1),('6-7-1','6-7',1,'k/11',-0.5),('6-7-2','6-7',2,'k %11',1),('6-7-3','6-7',3,'k/11 = = 0 ',-0.5),('6-7-4','6-7',4,'k % 11 = = 0',-0.5),('6-8-1','6-8',1,'-1',-0.5),('6-8-2','6-8',2,'1',-0.5),('6-8-3','6-8',3,'8',-0.5),('6-8-4','6-8',4,'0',1),('6-9-1','6-9',1,'a = 3 , b = 11',-0.5),('6-9-2','6-9',2,'a = 2 , b = 8 ',1),('6-9-3','6-9',3,'a = 1, b = -1',-0.5),('6-9-4','6-9',4,'a = 4, b = 9',-0.5),('7-1-1','7-1',1,'整型常量',-0.5),('7-1-2','7-1',2,'整型表达式',-0.5),('7-1-3','7-1',3,'整型常量或者整型表达式',1),('7-1-4','7-1',4,'任何类型的表达式',-0.5),('7-10-1','7-10',1,'if(s1>s2)',-0.5),('7-10-2','7-10',2,'if(strcmp(s1>s2))',-0.5),('7-10-3','7-10',3,'if(strcmp(s2,s1)>0)',-0.5),('7-10-4','7-10',4,'if(strcmp(s1,s2)>0)',1),('7-11-1','7-11',1,'数组x和数组y等价',-0.5),('7-11-2','7-11',2,'数组x和数组y的长度相同',-0.5),('7-11-3','7-11',3,'数组x的长度大于数组y的长度',1),('7-11-4','7-11',4,'数组x的长度小于数组y的长度',-0.5),('7-12-1','7-12',1,'9 9',-0.5),('7-12-2','7-12',2,'5 20',1),('7-12-3','7-12',3,'13 20',-0.5),('7-12-4','7-12',4,'20 20',-0.5),('7-13-1','7-13',1,'3 5 7',1),('7-13-2','7-13',2,'3 6 9',-0.5),('7-13-3','7-13',3,'1 5 9',-0.5),('7-13-4','7-13',4,'1 4 7',-0.5),('7-14-1','7-14',1,'ABC6789',1),('7-14-2','7-14',2,'ABC67',-0.5),('7-14-3','7-14',3,'12345ABC6',-0.5),('7-14-4','7-14',4,'ABC456789',-0.5),('7-15-1','7-15',1,'ABCD    FGH    KL    M',-0.5),('7-15-2','7-15',2,'ABCD    EFG    IJ',-0.5),('7-15-3','7-15',3,'EFG    JK&    O',-0.5),('7-15-4','7-15',4,'EFGH    IJKL',1),('7-16-1','7-16',1,'you&me',1),('7-16-2','7-16',2,'you',-0.5),('7-16-3','7-16',3,'me',-0.5),('7-16-4','7-16',4,'arr',-0.5),('7-17-1','7-17',1,'str1=str2;',1),('7-17-2','7-17',2,'strcpy(str1,str2);',-0.5),('7-17-3','7-17',3,'strcpy(str1,str2,6);',-0.5),('7-17-4','7-17',4,'memcpy(str1,str2,5);',-0.5),('7-18-1','7-18',1,'\'a\'\'b\'',-0.5),('7-18-2','7-18',2,'ab',1),('7-18-3','7-18',3,'ab□c',-0.5),('7-18-4','7-18',4,'ab□',-0.5),('7-19-1','7-19',1,'□',-0.5),('7-19-2','7-19',2,'\\0',-0.5),('7-19-3','7-19',3,'e',1),('7-19-4','7-19',4,'f',-0.5),('7-2-1','7-2',1,'a[10];',-0.5),('7-2-2','7-2',2,'a[3.5];',-0.5),('7-2-3','7-2',3,'a(2);',-0.5),('7-2-4','7-2',4,'a[10-10];',1),('7-20-1','7-20',1,'12ba56',-0.5),('7-20-2','7-20',2,'6521',-0.5),('7-20-3','7-20',3,'6',1),('7-20-4','7-20',4,'62',-0.5),('7-3-1','7-3',1,'4个字节',-0.5),('7-3-2','7-3',2,'5个字节',-0.5),('7-3-3','7-3',3,'6个字节',1),('7-3-4','7-3',4,'7个字节',-0.5),('7-4-1','7-4',1,'j * m + i',-0.5),('7-4-2','7-4',2,'i * m + j',1),('7-4-3','7-4',3,'i * m + j - 1',-0.5),('7-4-4','7-4',4,'i * m + j + 1',-0.5),('7-5-1','7-5',1,'0',-0.5),('7-5-2','7-5',2,'3',1),('7-5-3','7-5',3,'4',-0.5),('7-5-4','7-5',4,'无确定值',-0.5),('7-6-1','7-6',1,'double x[5]={12.0,4.0,6.0,8.0,10.0};',-0.5),('7-6-2','7-6',2,'int y[5]={0,1,3,5,7,9};',1),('7-6-3','7-6',3,'char c1[]={\'1\', \'2\', \'3\', \'4\', \'5\'};',-0.5),('7-6-4','7-6',4,'char c2[]={\'\\x10\', \'\\xa\', \'\\x8\' };',-0.5),('7-7-1','7-7',1,'int a[2][3]={0};',-0.5),('7-7-2','7-7',2,'int a[][3]={{1,2}，{0}};',-0.5),('7-7-3','7-7',3,'int a[2][3]={{1,2}，{3,4}，{5,6}};',1),('7-7-4','7-7',4,'int a[][3]={1,2,3,4,5,6};',-0.5),('7-8-1','7-8',1,'int a[2][]={{1,0,1},{5,2,3}};',-0.5),('7-8-2','7-8',2,'int a[][3]={{1,2,3}，{4,5,6}};',1),('7-8-3','7-8',3,'int a[2][4]={{1,2,3}，{4,5}，{6}};',-0.5),('7-8-4','7-8',4,'int a[][3]= {{1,0,1}，{ }，{1,1}};',-0.5),('7-9-1','7-9',1,'char str[5]=\'\'good!\'\';',1),('7-9-2','7-9',2,'char str[]=\'\'good!\'\';',-0.5),('7-9-3','7-9',3,'char str[8]=\'\'good!\'\';',-0.5),('7-9-4','7-9',4,'char str[5]={\'g\', \'o\', \'o\', \'d\'};',-0.5),('8-1-1','8-1',1,'用户若需调用标准库函数，调用前必须重新定义',-0.5),('8-1-2','8-1',2,'用户可以重新定义标准库函数，若如此，该函数将失去原有含义',1),('8-1-3','8-1',3,'系统根本不允许用户重新定义标准库函数',-0.5),('8-1-4','8-1',4,'用户若需调用标准库函数，调用前不必使用预编译命令将该函数所在文件包括到用户源文件中，系统自动去调',-0.5),('8-10-1','8-10',1,'return语句中的表达式类型所决定',-0.5),('8-10-2','8-10',2,'调用该函数时的主调函数类型所决定',-0.5),('8-10-3','8-10',3,'调用该函数时系统临时决定',-0.5),('8-10-4','8-10',4,'在定义该函数时所指定的函数类型所决定',1),('8-11-1','8-11',1,'地址传递',-0.5),('8-11-2','8-11',2,'单向值传递',1),('8-11-3','8-11',3,'由实参传给形参，再由形参传回给实参',-0.5),('8-11-4','8-11',4,'由用户指定的传递方式',-0.5),('8-12-1','8-12',1,'auto和static',-0.5),('8-12-2','8-12',2,'auto和register',1),('8-12-3','8-12',3,'register和static',-0.5),('8-12-4','8-12',4,'extern和register',-0.5),('8-13-1','8-13',1,'在不同的函数中可以使用相同名字的变量',-0.5),('8-13-2','8-13',2,'函数中的形式参数是局部变量',-0.5),('8-13-3','8-13',3,'在一函数内定义的变量只在本函数范围内有效',-0.5),('8-13-4','8-13',4,'在一个函数内的复合语句中定义的变量在本函数范围内有效',1),('8-14-1','8-14',1,'f (int array[ ][6])',-0.5),('8-14-2','8-14',2,'f(int array[3][[ ])',-0.5),('8-14-3','8-14',3,'f (int array[ ][4])',1),('8-14-4','8-14',4,'f(int array[2][5])',-0.5),('8-15-1','8-15',1,'.编译出错',-0.5),('8-15-2','8-15',2,'9',1),('8-15-3','8-15',3,'21',-0.5),('8-15-4','8-15',4,'9.0',-0.5),('8-16-1','8-16',1,'hello',-0.5),('8-16-2','8-16',2,'hel',-0.5),('8-16-3','8-16',3,'hlo',1),('8-16-4','8-16',4,'hlm',-0.5),('8-17-1','8-17',1,'4',-0.5),('8-17-2','8-17',2,'3',1),('8-17-3','8-17',3,'2',-0.5),('8-17-4','8-17',4,'1',-0.5),('8-18-1','8-18',1,'3  3',-0.5),('8-18-2','8-18',2,'2  2',-0.5),('8-18-3','8-18',3,'2  6',1),('8-18-4','8-18',4,'2  5',-0.5),('8-19-1','8-19',1,'8',1),('8-19-2','8-19',2,'10',-0.5),('8-19-3','8-19',3,'7',-0.5),('8-19-4','8-19',4,'11',-0.5),('8-2-1','8-2',1,'实参可以是常量，变量或者表达式',-0.5),('8-2-2','8-2',2,'形参可以是常量，变量或者表达式',1),('8-2-3','8-2',3,'实参可以为任何类型',-0.5),('8-2-4','8-2',4,'形参应与其对应的实参类型一致',-0.5),('8-20-1','8-20',1,'5,4,3,2,1,',1),('8-20-2','8-20',2,'5,2,3,4,1,',-0.5),('8-20-3','8-20',3,'1,2,3,4,5,',-0.5),('8-20-4','8-20',4,'1,2,3,4,5,',-0.5),('8-3-1','8-3',1,'double fun（int x，int y）',1),('8-3-2','8-3',2,'double fun（int x；int y）',-0.5),('8-3-3','8-3',3,'double fun（int x，int y）；',-0.5),('8-3-4','8-3',4,'double fun（int x，y）',-0.5),('8-4-1','8-4',1,'定义函数时，形参的类型说明可以放在函数体内',-0.5),('8-4-2','8-4',2,'return后边的值不能为表达式',-0.5),('8-4-3','8-4',3,'如果函数值得类型与返回值类型不一致，以函数值类型为准',1),('8-4-4','8-4',4,'如果形参与实参类型不一致，以实参类型为准',-0.5),('8-5-1','8-5',1,'auto',-0.5),('8-5-2','8-5',2,'static',-0.5),('8-5-3','8-5',3,'extern',1),('8-5-4','8-5',4,'无存储类别',-0.5),('8-6-1','8-6',1,'自动（auto）',1),('8-6-2','8-6',2,'静态（static）',-0.5),('8-6-3','8-6',3,'外部（extern）',-0.5),('8-6-4','8-6',4,'寄存器（register）',-0.5),('8-7-1','8-7',1,'必须在主调函数中说明此数组的大小',1),('8-7-2','8-7',2,'实参数组类型与形参数组类型可以不匹配',-0.5),('8-7-3','8-7',3,'在被调用函数中，不需要考虑形参数组的大小',-0.5),('8-7-4','8-7',4,'实参数组名与形参数组名必须一致',-0.5),('8-8-1','8-8',1,'数组的首地址',1),('8-8-2','8-8',2,'数组第一个元素的值',-0.5),('8-8-3','8-8',3,'数组中全部元素的值',-0.5),('8-8-4','8-8',4,'数组元素的个数',-0.5),('8-9-1','8-9',1,'出现在执行语句中',-0.5),('8-9-2','8-9',2,'出现在一个表达式中',-0.5),('8-9-3','8-9',3,'作为一个函数的实参',-0.5),('8-9-4','8-9',4,'作为一个函数的形参',1),('9-1-1','9-1',1,'char s[5]={＂ABCDE＂}; ',0),('9-1-2','9-1',2,'char s[5]={‘A’,’B’,’C’,’D’,’E’};',0.5),('9-1-3','9-1',3,'char*s;s=＂ABCDE＂; ',1),('9-1-4','9-1',4,'char*s;  scanf(＂%s＂,  s);',0),('9-10-1','9-10',1,'&a[0]+1',0),('9-10-2','9-10',2,'&a[1] ',0),('9-10-3','9-10',3,'&a[0]++',1),('9-10-4','9-10',4,'a+1',0),('9-11-1','9-11',1,'x++ ',0),('9-11-2','9-11',2,'&ptr ',0),('9-11-3','9-11',3,'&ptr[k]  ',1),('9-11-4','9-11',4,'&(x+1)',0),('9-12-1','9-12',1,'char a[11],*p;strcpy(p=a+1,&st[4]);',1),('9-12-2','9-12',2,'char a[11]; strcpy(++a,st);',0),('9-12-3','9-12',3,'char a[11];strcpy(a,st);',0),('9-12-4','9-12',4,'char a[ ],*p;strcpy(p=a[1],st+2);',0),('9-13-1','9-13',1,'8',0),('9-13-2','9-13',2,'12',0),('9-13-3','9-13',3,'4',1),('9-13-4','9-13',4,'7',0),('9-14-1','9-14',1,'9',0),('9-14-2','9-14',2,'5',0),('9-14-3','9-14',3,'6',1),('9-14-4','9-14',4,'7',0),('9-15-1','9-15',1,'bcdefgh ',0),('9-15-2','9-15',2,'cdefgh   ',0),('9-15-3','9-15',3,'defgh  ',0),('9-15-4','9-15',4,'efgh',1),('9-16-1','9-16',1,'array[i][j]   ',0),('9-16-2','9-16',2,'*(*(array+i)+j)',0),('9-16-3','9-16',3,'(array[i]+j) ',0),('9-16-4','9-16',4,'*(array+i*4+j)',1),('9-17-1','9-17',1,'5,2,3',0),('9-17-2','9-17',2,'—5,—12,—7',1),('9-17-3','9-17',3,'—5,-—12,—17 ',0),('9-17-4','9-17',4,'5,—2,-—7',0),('9-18-1','9-18',1,'一个用于指向整型数据的指针变量',0),('9-18-2','9-18',2,'一个用于指向一维数组的行指针',0),('9-18-3','9-18',3,'一个用于指向函数的指针变量',0),('9-18-4','9-18',4,'一个返回值为指针型的函数名',1),('9-19-1','9-19',1,'a=a(w);',0),('9-19-2','9-19',2,'(*a) (?c); ',1),('9-19-3','9-19',3,'b=*b(w); ',0),('9-19-4','9-19',4,'fun(b);',0),('9-2-1','9-2',1,'< ',0),('9-2-2','9-2',2,'=',0),('9-2-3','9-2',3,'+',1),('9-2-4','9-2',4,'-',0),('9-20-1','9-20',1,'p=2*(short*)malloc(sizeof(short));',1),('9-20-2','9-20',2,'p=(short*)malloc(2*sizeof(short));',0),('9-20-3','9-20',3,'p=(short*)malloc(2*2);',0),('9-20-4','9-20',4,'p=(short*)calloc(2,sizeof(short));',0),('9-21-1','9-21',1,'ps+1  ',0),('9-21-2','9-21',2,'*(ps+3)  ',0),('9-21-3','9-21',3,'ps[0][2] ',1),('9-21-4','9-21',4,'*(ps+1)+3',0),('9-22-1','9-22',1,' def def  ',1),('9-22-2','9-22',2,'abc def   ',0),('9-22-3','9-22',3,'abc abc ',0),('9-22-4','9-22',4,'def  abc',0),('9-23-1','9-23',1,'ABCDDEFEDBD   ',0),('9-23-2','9-23',2,'abcDDfetDbD',1),('9-23-3','9-23',3,'abcAAfefAbA ',0),('9-23-4','9-23',4,'Abcddfefdbd',0),('9-24-1','9-24',1,'double*p ',0),('9-24-2','9-24',2,'float**p',0),('9-24-3','9-24',3,'double**p',1),('9-24-4','9-24',4,'float*p',0),('9-25-1','9-25',1,'386net ',0),('9-25-2','9-25',2,'prop.exe -386net',0),('9-25-3','9-25',3,'prop.exe -386net ',0),('9-25-4','9-25',4,'prog -386 net',1),('9-3-1','9-3',1,'char  a[10]=＂china＂; ',0),('9-3-2','9-3',2,'char  a [10],*p=a;p=＂china＂;',0),('9-3-3','9-3',3,'char*a;a=＂chins＂;    ',0),('9-3-4','9-3',4,'char a[10],*p;p=a=＂china＂;',1),('9-4-1','9-4',1,'s和p完全相同',0),('9-4-2','9-4',2,'数组s中的内容和指针变量p中的内容相等',0),('9-4-3','9-4',3,'s数组长度和p所指向的字符串长度相等',0),('9-4-4','9-4',4,'*p与s[0]相等',1),('9-5-1','9-5',1,'p=&n;scanf(＂%d＂,&p);  ',0),('9-5-2','9-5',2,'p=&n;scanf(＂%d＂,*p)',0),('9-5-3','9-5',3,'scanf(＂%d＂,&n);*p=n; ',0),('9-5-4','9-5',4,'p=&n;*p=m;',1),('9-6-1','9-6',1,'a,point,*&a   ',0),('9-6-2','9-6',2,'&*a,&a,*point',0),('9-6-3','9-6',3,'*&point,*point,&a   ',0),('9-6-4','9-6',4,'&a,&*point,point',1),('9-7-1','9-7',1,'值',0),('9-7-2','9-7',2,'地址   ',1),('9-7-3','9-7',3,'名',0),('9-7-4','9-7',4,'一个标志',0),('9-8-1','9-8',1,'k=*ptrl+*ptr2;    ',0),('9-8-2','9-8',2,'ptr2=k;',1),('9-8-3','9-8',3,'ptrl=ptr2; ',0),('9-8-4','9-8',4,'k=*ptrl*(*ptr2);',0),('9-9-1','9-9',1,'i=*p;',0),('9-9-2','9-9',2,'p=*&j;',1),('9-9-3','9-9',3,'i=&j; ',0),('9-9-4','9-9',4,'i=**p;',0);
/*!40000 ALTER TABLE `options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `selection`
--

DROP TABLE IF EXISTS `selection`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `selection` (
  `id` varchar(20) CHARACTER SET gbk NOT NULL,
  `content` text CHARACTER SET gbk NOT NULL,
  `answer` text CHARACTER SET gbk NOT NULL,
  `chapter` int(11) DEFAULT NULL,
  `explanation` text CHARACTER SET gbk,
  `rights` int(11) DEFAULT '0',
  `wrongs` int(11) DEFAULT '0',
  `rate` double DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `selection`
--

LOCK TABLES `selection` WRITE;
/*!40000 ALTER TABLE `selection` DISABLE KEYS */;
INSERT INTO `selection` VALUES ('1-1','计算机工作时，内存储器用来存储(    )。','C',1,'计算机内存按所存信息的类别一般分为两大类，即程序和数据。程序是用来控制计算机完成某项任务的指令的集合，而数据时程序运行处理的对象。A只说明是程序，B和D只说明是数据，因为信号和ASCII码均为数据，所以选C。',1,1,0.5),('1-10','将250与5进行按位与的结果是 (    )。','A',1,'无',1,1,0.5),('1-11','将(AF)16与(78)16进行按位异或的结果是(    )。','A',1,'(AF)16^(78)16=(10101111)2^(01111000)2=(11010111)2=(D7)16，所以选A。',1,1,0.5),('1-12','将（717）8进行按位求反的结果是 (    )。','B',1,'无',1,1,0.5),('1-13','将二进制数10110010的最高位求反的操作是(    )。','A',1,'A:(10110010)2&(7F)16=(10110010)2&(01111111)2=(00110010)2',1,1,0.5),('1-14','将二进制数10110010的高4位求反，低4位不变的操作是(    )。','B',1,'高4位求反，可以将高4位与(1111)2进行按位异或得到；低4位不变，可将低4位与(0000)2进行按位异或得到，故可与(11110000)2进行按位异或来实现题目的要求。所以选择B。其他均不正确。',1,1,0.5),('1-2','语言编译程序若按软件分类则是属于(    )。','A',1,'软件根据用途分为两大类：系统软件和应用软件。各种语言的编译程序都是属于系统软件。C和D都是具体的软件，均属于系统软件。所以选A。',1,1,0.5),('1-3','十进制数35转换成二进制数是(    )。','A',1,'(35)10=(32)10+(3)10=(100000)2+(11)2=(100011)2，所以选A。',1,1,0.5),('1-4','十进制数268转换成十六进制数是(    )。','B',1,'(268)10=(256)10+(12)10=(100000000)2+(1100)2=(100001100)2=(10C)16，所以选B。  ',1,1,0.5),('1-5','下列无符号整数中最大的数是(    )。','D',1,'(10100011)2=(163)10，(FF)16=(255)10，(237)8=(183)10，所以选D。',1,1,0.5),('1-6','与二进制数0.1等值的十六进制小数为(    )。','D',1,'(0.1)2=(0.5000)10=(0.8)16，所以选D。  ',1,1,0.5),('1-7','真值为-100101的数在字长为8的机器中，其补码形式为(    )。','A',1,'(-100101)原=10100101，故(-100101)补=11011011，所以选A。',1,1,0.5),('1-8','若X补=0.1101010 ，则X原= (    )。','D',1,'因为x的符号位为0，所以x为正数，则X原与X补相同，所以选D。 ',1,1,0.5),('1-9','若X=+1101，Y=-1011，则[X+Y]补= (    )。','A',1,'[X+Y]补=[X]补+[Y]补=01101+10101=00010(其中最高符号位产生的进位丢掉)，所以选A。',1,1,0.5),('10-1','以下叙述中不正确的是（     ）。','C',10,'C程序中的预处理命令行是在预编译时进行处理的，而不是在程序执行过程中处理的。所以应选择C。',1,1,0.5),('10-2','<html>以下程序的运行结果是（     ）。<br/>#define MIN (x, y) (x) < (y) ? (x) : (y)<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int i = 10, j = 15, k;<br/>&nbsp;&nbsp;&nbsp;&nbsp;k = 10 * MIN (i, j);<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d\\n\", k);<br/>}<br/></html>','B',10,'语句k=10*MIN(i,j);在预编译时将进行宏替换为k=10 * (i)<(j) ? (i) : (j);。',1,1,0.5),('10-3','以下叙述中正确的是（     ）。','C',10,'C语言规定，在程序的一行上只能出现一个有效的预处理命令行；使用带有参数的宏时，参数类型可以与宏定义时的类型不一致，因为宏替换时是纯文本替换；对于宏定义:#define C  R  045，C是宏名，而不是C  R；所以大难A、B、D都是错误的。正确答案是C，因为宏替换是在预编译时进行的，不是在执行时进行的。',1,1,0.5),('10-4','<html>以下程序运行的结果是（     ）。<br/>#define ADD (x) x+x<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int m =1, n =2, k=3;<br/>&nbsp;&nbsp;&nbsp;&nbsp;int sum =ADD (m+n) * k;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"sum = %d\", sum);<br/>}</html>','B',10,'语句sum = ADD(m+n) * k;在预编译时将进行宏替换为sum=m+n+m+n*k;。',1,1,0.5),('10-5','<html>程序中头文件types.h的内容如下:<br/>#define N 5<br/>#define M1 N*3$<br/></html>程序如下：<html><br/>#define \"types.h\"<br/>#define M2 N*2<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int i;<br/>&nbsp;&nbsp;&nbsp;&nbsp;i = M1 + M2;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d\\n\", i);<br/>}<br/></html>程序编译后运行的输出结果是（     ）。','C',10,'语句i =M1 + M2;在预编译时将进行宏替换为i=5*3+5*2;因此i的 值将是25.故正确答案是C。',1,1,0.5),('10-6',' 以下叙述正确的是（     ）。','B',10,'C语言中，除了关键字以外的单词串都可以定义成标示符。define不是关键字，所以可以把define定义成标示符，但if是关键字，所以不能定义成标示符。故正确答案是B。',1,1,0.5),('10-7',' 若有以下说明和定义则叙述正确的是（     ）。','B',10,'进行类型定义以后，INTEGER其实就是基类型为int的指针类型，然后由INTEGER来定义两个变量p和*q，则p是基类型为int型的一级指针变量，而q是基类型为int型的二级指针变量。故正确答案是B。',1,1,0.5),('10-8','从下列选项中选择不会引起二义性的宏定义是（     ）。','D',10,'要想让宏定义不产生二义性，就是将参数及宏体都加上小括号即可。故正确答案是D。',1,1,0.5),('10-9','<html>以下程序运行的结果是（     ）。<br/>#define X  5<br/>#define Y  X + 1<br/>#define Z Y * X / 2<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a = Y;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d, %d\", Z, --a);<br/>}</html>','D',10,'先来计算Z的值，Z将替换成Y*X/2，再把X+1替换Y，得Z=X+1*X/2，再用5替换X，得Z=5+1*5/2，所以Z的值是7（主义整除）。a=Y宏替换后变成a=X+1,再将5替换X，得a=5+1，即a的值是6，但输出是--a，a先减1即变为5，再输出。故正确答案是D。',1,1,0.5),('11-1','在16位 C语言编译系统上，当说明一个结构体变量时系统分配给它的内存是（     ）。','A',11,'在16位C语言 编译系统上，C语言中结构体变量所占内存的大小是其所包含的各个成员所需内存大小之和。故正确答案是A。',1,1,0.5),('11-10','<html> 在16位IBM-PC上，若有下面的说明和定义：<br/>struct test<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int m1;  char m2;  float m3;<br/>&nbsp;&nbsp;&nbsp;&nbsp;union uu { char u1[5];  int u2[2] ; } ua;<br/>} myaa;<br/></html>则sizeof(struct test)的值是（     ）。','A',11,'sizeof(struct test)其实就是计算结构体变量myaa所占内存的字节数，它应当',1,1,0.5),('11-11','<html>以下程序的输出是（     ）。<br/>struct st { int x; int *y} *p;<br/>int dt[4] = {10, 20, 30, 40 };<br/>struct st aa[4]={ 50, &dt[0], 60, &dt[0], 60, &dt[0], 60, &dt[0]};<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;p = aa;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d\\n\", ++(p->x));<br/>}<br/></html>','C',11,' aa是大侠为4的结构提数组，p是一指向该结构体的指针，将数组名aa赋给',1,1,0.5),('11-12','<html>以下程序的输出是（     ）。<br/>union myun<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;struct { int x, y, z;} u;<br/>&nbsp;&nbsp;&nbsp;&nbsp;int k;<br/>} a;<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;a.u.x = 4; a.u.y = 5; a.u.z = 6;<br/>&nbsp;&nbsp;&nbsp;&nbsp;a.k = 0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d\\n\",a.u.x);<br/>}<br/></html>','D',11,'变量a是一联合体变量，其包含两个成员：一个是结构体类型成员u，一个',1,1,0.5),('11-13','<html>以下程序的输出是（     ）。<br/>struct HAR { int x, y; struct HAR *p;}h[2];<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;h[0].x = 1; h[0].y = 2;<br/>&nbsp;&nbsp;&nbsp;&nbsp;h[1].x = 3; h[1].y = 4;<br/>&nbsp;&nbsp;&nbsp;&nbsp;h[0].x = &h[1]; h[L].p = h;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d, %d \\n\", (h[0].p->x, (h[1].0->y);<br/>}<br/></html>','D',11,'h是大小为2的结构体数组对其两个元素进行赋值后其输出结果应为3，2。故正确答案是D。',1,1,0.5),('11-14','<html>以下程序的输出是（     ）。<br/>struct NoDE { int num; struct NODE *next; };<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;struct NODE *p, *Q , *R;<br/>&nbsp;&nbsp;&nbsp;&nbsp;p = (struct NODE *) malloc (sizeof (struct NODE) );<br/>&nbsp;&nbsp;&nbsp;&nbsp;q = (struct NODE *) malloc (sizeof (struct NODE) );<br/>&nbsp;&nbsp;&nbsp;&nbsp;r = (struct NODE *) malloc (sizeof (struct NODE) );<br/>&nbsp;&nbsp;&nbsp;&nbsp;p->num = 10; q->next = r;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (\"%d\\n\", p->num + q->next->num);<br/>}<br/></html>','D',11,'p、q、r是3个指向结构体的指针变量，通过动态内存分配分别为它们分配',1,1,0.5),('11-15','<html>执行以下语句后的输出结果是（     ）<br/>enum weekday (sun, mon = 3, tue , wed , thu};<br/>enum weekday workday;<br/>printf (\"%d\\n\",workday);<br/></html>','A',11,'在枚举类型weekday中，因mon的值为3，则tue的值为4，wed的值就为5，',1,1,0.5),('11-2','<html>设有以下说明语句，则下面的叙述不正确的是（     ）。<br/>struct stu<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a;<br/>&nbsp;&nbsp;&nbsp;&nbsp;filat b; <br/>}stutype;<br/></html>','C',11,' stutype是类型为struct stu的结构体变量，不是结构体类型名。故选择答案',1,1,0.5),('11-3','C语言结构体类型变量在程序执行期间（     ）。','A',11,'结构体变量不管其包含有多少个成员，都应当看成是一个整体。在程序运行',1,1,0.5),('11-4','<html>在16位IBM-PC上使用C语言，若有如下定义：<br/>struct data<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int i;<br/>&nbsp;&nbsp;&nbsp;&nbsp;char ch;<br/>&nbsp;&nbsp;&nbsp;&nbsp;double f;<br/>} b;<br/></html>则结构变量b占用内存的字节数是（     ）。','D',11,'结构体变量b所占内存的字节数是其成员所占内存字节数之和。在16位机',1,1,0.5),('11-5','<html>根据下面的定义，能打印出字母M的语句是（     ）。<br/>struct person<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char name[10];<br/>&nbsp;&nbsp;&nbsp;&nbsp;int age;<br/>};<br/>struct person class[10] = (\"John\", 17, \"Pall\", 19, \"Mary\", 18, \"adam\", 16);<br/></html>','D',11,'包含大写字母M的结构体只有结构体数组的第3个元素class[2]，class[2]包',1,1,0.5),('11-7','<html>设有如下定义：<br/>struck sk<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a;<br/>&nbsp;&nbsp;&nbsp;&nbsp;float b;<br/>} data ;<br/>int *p;<br/></html>若要使p指向data中的a域，正确的赋值语句是（     ）。','C',11,'要使p指向data中的a成员，则只需将data中成员a的地址，即&data,a赋',1,1,0.5),('11-8','有以下结构体说明和变量的定义，且指针p指向变量a，指针q指向变量b。则不能把结点b连接到结点a之后的语句是（     ）。<html><br/>struct node<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;struct node *next;<br/>} a,b,*p = &a, *q = &b;<br/></html>','B',11,'p是一指向结构体类型的指针变量，其初始值是让其指向结构体变量a，要通',1,1,0.5),('11-9','<html>有以下程序，程序运行后的输出结果是（     ）。<br/>struct STU<br/>{ char num[10]; float score[3]; };<br/>void main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;struct STU s[3] = { {“20021”, 90, 95, 85},<br/>&nbsp;&nbsp;&nbsp;&nbsp;{“20022”, 95, 80, 75}<br/>&nbsp;&nbsp;&nbsp;&nbsp;{“20023”, 100, 95 90} }, *p = s;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Int I; ploat sum = 0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for ( i = 0; i < 3, i++ )<br/>&nbsp;&nbsp;&nbsp;&nbsp;sum = sum + p->score[i];<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (“%6.2f\\n”, sum);<br/>}<br/></html>','B',11,' s是具有3个元素的结构体数组，p为一指向结构体的指针变量，开始时将数',1,1,0.5),('12-1','fscanf函数的正确调用形式是（     ）','D',12,'fscanf函数与scanf函数的主要区别就是在fscanf函数中第一个形参是文件指针，其他参数与scanf完全相同。故正确答案是D。',1,1,0.5),('12-10','若执行fopen函数时发生错误，，则函数的返回值是（    ）','B',12,'执行fopen函数时，如果文件打开成功，则返回该文件结构体的指针，如果打开失败（例如，读打开时文件不存在，写打开时文件不能创建），则返回NULL(即0)。故选择答案是B',1,1,0.5),('12-11','当顺利执行了文件关闭操作时，fclose函数的返回值是（    ）','C',12,'如果正常关闭了文件，则函数返回值为0；否则，返回值为非0。故选择答案是C。',1,1,0.5),('12-12','若以“a+”方式打开一个已存在的文件，则以下叙述正确的是（    ）','A',12,' 若以“a+”方式打开一个已存在的文件，原文件如果不存在，则创建，如果存在则打开，并且将文件位置指针移到文件尾，可以在文件尾进行数据添加，也可以从文件开头处进行读数，但文件位置指针不可移到文件头，不能进行重写操作。故选择答案是A。',1,1,0.5),('12-13','若要用fopen函数打开一个新的二进制文件，该文件既能读也能写，则文件方式字符串应该（    ）','B',12,'因为要打开一个新的二进制文件，则表示应具备文件创建的功能，所以文件方式字符串中应包含w和b。又因为要对打开的文件既能读又能写，所以文件方式字符串中还应包含+。故选择答案是B。',1,1,0.5),('12-14','fgetc函数的作用是从指定文件读入一个字符，该文件的打开方式必须是（    ）','D',12,'fgetc函数要求文件的打开方式必须是以读或者读写的方式或者追加的方式，只写方式是不能读的。。故选择答案是D。',1,1,0.5),('12-15','若fp是指向某文件的指针，且已读到此文件末尾，则库函数feof(fp)的返回值是（   ）','C',12,'在执行读文件操作时，如果遇到文件尾，则函数feof(fp)返回逻辑真（非0值）；否则，返回逻辑假（0）。故选择答案是C。',1,1,0.5),('12-16','若要打开A盘上user子目录下名为abc.txt的文本文件进行读、写操作，下面符合此要求的函数调用是（    ）','B',12,' 如果要对文件进行读、写操作，则文件打开方式字符串中必须有+。答安A和C都只能对文件进行读操作，答案D则只能对文件进行写操作。故选答案是B。',1,1,0.5),('12-17','<html>下面的程序执行后，文件test.txt中的内容是（     ）<br/>#include <stdio.h><br/>void  fun (char *fname, char *st)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;FLLE *myf; int  i ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;myf = fopen  (fname , “w” );<br/>&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0 ; i< strlen (st) ; i++)  fputc (st[1], myf) ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;fclose  (myf) ;<br/>}<br/>void  main (  )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;fun(“test.txt”,”new  world”);<br/>&nbsp;&nbsp;&nbsp;&nbsp;fun(“test.txt”,”hello,”) ;<br/>}<br/></html>','A',12,'函数fun的功能就是将第二个参数字符串写入到文件test.txt中，但因为打开文件test.txt的方式是以只写方式，所以每次调用函数fun后都会将原来文件内容清除（如果test.txt文件存在），这样一来test.txt中的内容将是最后一次调用fun函数写入的字符串。故选择答案是A。',1,1,0.5),('12-18','以下叙述中错误的是（    ）','A',12,'二进制文件和顺序文件并不是两个相互独立的概念，不存在二进制文件打开后可以读文件的末尾，而顺序文件不可以的情况。故选择答案是A。',1,1,0.5),('12-19','函数ftell(fp)的作用是（    ）','A',12,'函数ftell(fp)的作用就是返回fp所指向的文件的当前位置指针的值（用相对文件开头的位移量表示）。故选择答案是A。',1,1,0.5),('12-2','函数rewind 的作用是（    ）','A',12,'rewind 函数的作用就是将文件位置指针重新指向文件的开始位置。故正确答案是A。',1,1,0.5),('12-20','在C程序中，可把整型数以二进制形式存放到文件中的函数是（    ）','C',12,'intf函数只能以字符串的形式写入到文件中；fread函数则是从文件中读数据，而不是写数据；fputc函数是以字符的形式写到文件中；而fwrite函数则是将某数以其机器数的形式写入到文件中。故选择答案是C。',1,1,0.5),('12-21','<html>以下程序运行的输出结果是（      ）<br/>void  main  (    )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp; FILE  * fp ;  int  i =  20, j = 30, k, n ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;fp = fopen (“dd.dat”, “w” ) ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;fprintf  (fp, “%d\\n”, i); fprintf (fp, \\\\ d \\n ,j);<br/>&nbsp;&nbsp;&nbsp;&nbsp;fclose  (fp) ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;fp = fopen (“dd.dat” ,”r”) ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;fscanf  (fp,”%d%d, &k,&n);printf (“%d, %d\\n”, k, n);<br/>&nbsp;&nbsp;&nbsp;&nbsp;fclose (fp);<br/>}<br/></html>','A',12,'该程序的功能就是将两个整型数i和j的值通过fprintf函数将它们转换成字符串的形式（包含\\n）写入到文件dd.dat中，然后通过fscanf函数从文件dd.dat中格式化读出到变量k和n中，所以k的值将是20，n的值将是30。故选择答案是A。',1,1,0.5),('12-22','已知函数的调用形式：fread（buffer, size, count, fp）；其中buffer代表的是（      ）。','C',12,'fread函数的功能就是从fp所代表的文件中读取count*size个字节的数据存放到指针buffer所指向的内存块中。故选择答案是C。',1,1,0.5),('12-3','fseek函数的正确调用形式是（    ）','B',12,'fseek函数的第一个参数是文件指针，第二个参数应是位移量，第三个参数是起始点。故正确答案是B。',1,1,0.5),('12-4','利用seek函数的正确调用形式是（    ）','D',12,'fseek函数的功能就是能将文件的位置指针进行定位，以实现对文件的随机读写，当然文件的顺序读写就更不成问题。故正确答案是D。',1,1,0.5),('12-5','函数调用语句fseek(fp,-20)；的含义是（    ）','C',12,'fseek函数的第三个参数有3个值可选：0表示文件的开始处，1表示当前位置，2表示文件尾；位移量为负，表示将文件位置指针往前移动。故正确答案是C。',1,1,0.5),('12-7','若调用fputc函数输出字符成功，则其返回值是（    ）','D',12,'fputc函数输出字符成功时，其返回值就是输出的字符。故选择答案是D。',1,1,0.5),('12-8','系统的标准输入文件是指（    ）','A',12,'C语言中，系统地标准输入文件就是指键盘。故选择答案是A。',1,1,0.5),('2-1','C语言属于(    )。','D',2,'机器语言是计算机唯一能识别的语言，是二进制语言，其他语言程序都必须将其编译为机器语言才能运行。低级语言是一种机器语言的符号化语言，像汇编语言。而其他语言一般是高级语言，C语言就是高级语言。所以选择D。',1,1,0.5),('2-10','C语言程序的注释是(    )。','A',2,'在标准C语言程序中，注释是由“/*”开头，“*/”结尾。在C++程序中，也可以由“//”开头对单位进行注释。所以选择A。',1,1,0.5),('2-11','C语言程序的语句都是以(    )结尾。','B',2,'根据C语言的规定，在程序中所有的语句均必须由“；”结尾。所以选择B。',1,1,0.5),('2-12','标准C语言程序的文件名的后缀为(    )。','A',2,'.c是标准C程序文件名的后缀；.cpp则是C++程序文件名的后缀；.obj是源程序经编译后所生成的目标文件的扩展名；.exe则是源程序经编译、链接后所生成的执行文件的扩展名。所以选择A。',1,1,0.5),('2-13','C语言程序经过编译以后生成的文件名的后缀为(    )。','B',2,'C语言源程序经编译后生成目标(object)文件，其文件名后缀为.obj。所以选择B。',1,1,0.5),('2-14','C语言程序经过链接以后生成的文件名的后缀为(    )。','C',2,'C语言源程序经链接后生成可执行(execute)文件，其文件名后缀为.exe。所以选择C。',1,1,0.5),('2-15','C语言编译程序的首要工作释是(    )。','A',2,'C语言编译程序的首要工作就是检查C语言程序中是否存在语法错误，如果有则给出错误的提示信息，如果没有则生成的目标文件(.obj)。编译程序对程序中的逻辑错误和程序的完整性是不检查的。所以选择A。',1,1,0.5),('2-2','C语言程序能够在不同的操作系统下运行，这说明C语言具有很好的(    )。','B',2,'所谓移植性就是在某操作系统下编写的程序能够在其他操作系统下编译运行，而程序几乎不需要进行任何修改。所以选择B。',1,1,0.5),('2-3','一个C语言程序是由(    )。','B',2,'C语言程序是由函数构成的，所谓函数是指功能相对独立的可以反复执行的一段程序，在某些程序设计语言中也称为过程，但C语言中叫函数。所以选择B。',1,1,0.5),('2-4','C语言规定，在一个源程序中，main函数的位置(    )。','C',2,'根据C语言的规定，任何程序有且只有一个main函数，main函数可以出现在程序的任何地方，没有位置的权限。所以选择C。',1,1,0.5),('2-5','C语言程序的执行，总是起始于(    )。','C',2,'在一个C语言源程序中，无论main函数书写在程序的前部，还是后部，程序的执行总是从main函数开始，并且在main函数中结束。所以选择C。',1,1,0.5),('2-6','下列说法中正确的是(    )。','C',2,'C语言严格区分大小写字母，如AI何aI被认为是两个不同的标示符，C语言程序的书写非常灵活，既可以一行多句，又可以一句多行，且每行不加行号。所以选择C。',1,1,0.5),('2-7','以下叙述不正确的是(    )。','D',2,'C语言程序是由函数组成的，有且只有一个main函数，所以C语言程序的基本组成单位是函数。故A、B、C的说法都是正确的。对于C语言中的注释可以出现在一条语句的后面，也可以出现在一句语句或者函数之前，故D是错误的。所以选择D。',1,1,0.5),('2-8','下列对C语言特点，不正确描述的是(    )。','C',2,'C语言是介于汇编语言和高级语言之间的一种语言，由于它可以 访问物理地址，对硬件操作，所以C语言既可以编写应用程序，又可以开发系统软件，而且C语言程序可移植性好于汇编语言，程序清晰，具有模块化的特点。所以选择C。',1,1,0.5),('2-9','C语言源程序的最小单位是(    )。','D',2,'程序行、语句、函数都是由字符构成的，字符是C语言的最小单位。所以选择D。',1,1,0.5),('3-1','在C语言系统中，假设int类型数据占2个字节，则double、long、unsigned int、char类型数据所占字节数分别多少(     )。','D',3,'C语言系统中，如果int型数据占2个字节，则说明该系统是16位的系统，此时double型数据占8个字节，long型数据占4个字节，unsigned int占2个字节，char型数据占1个字节，所以选择D。',1,1,0.5),('3-10','若有定义:int a=7; float x=4.7; 则表达式x+a%3*(int)(x+y)%2/4的值是 (     )。','A',3,'本题考查运算符的优先级概念，式中要先算(x+y)的值，再进行强制类型变换，*、/、%是同级的运算符，要从左到右计算，最后算加法。所以正确的结果是A。',1,1,0.5),('3-11','设变量a是整型，f是实型，i是双精度型，则表达式10+\'a\'+i*f值的数据类型为 (     )。','C',3,'不同类型数据混合运算的转换规律是：运算前float型数据会自动转换为double型，char型数据会自动转换为int型。运算时int型数据和double型数据要先化为相同类型，即double型，运算结果也为double型。所以正确答案为C。',1,1,0.5),('3-12','sizeof(float)是 (     )。','B',3,'sizeof是计算某数据类型的变量所占内存大小的运算符，其值是占用内存的字节数，为以整型值，所以正确答案是B。',1,1,0.5),('3-13','设变量n为float类型，m为int类型，则以下能实现将n中的数值保留小数点后两位，第三位进行四舍五入运算的表达式是 (     )。','B',3,'要实现将n中的数值保留小数点后两位，第三位进行四舍五入，则首先可将n乘以100，此时n*100的最低两位整数将是n的前两位小数，n*100的第一位小数将是n的第三位小数，再将n*100加上0.5，如果n*100的第一位小数(即n的第三位小数)大于或者等于0.5，则整数部分加1，否则整数部分不变，然后再将结果赋值给一整型变量其实就是将n*100+0.5的整数部分赋值给整型变量，从而完成了n的第三位小数的四舍五入操作，再将该整型变量除以100.0就得到了所希望的结果。所以正确答案是B。',1,1,0.5),('3-14','在C语言中，要求运算数必须是整型的运算符是','D',3,'/、+ +、！=运算符都可以对浮点数进行运算，但%只能对整型数据进行运算。所以应选择D。  ',1,1,0.5),('3-15','在C语言中，要求运算数必须是整型的运算符是 (     )。','C',3,'赋值运算符=的左边必须是变量，不能是表达式，所以D是非法的；对于C来说，int掉了括号，应写成(int) 18.5%3，所以也是错误的；A中的：=是非法的运算符。而B得功能是将c+2的值赋值给b，再将b的值赋值给a，是正确的，所以应选择B。',1,1,0.5),('3-16','若有定义：int k=7，x=12；，则能使值为3的表达式是','D',3,'通过调用getchar函数将输入的第一个字符赋给c1，所以c1的值是字符”1”，接下来调用scanf函数将输入的两位数赋给整型变量a1，但此时输入的A的计算结果为6；B的计算结果为2；C的计算结果为2；D的计算结果为3，因为(x%=k)的结果是5，而(k%=5)得结果是2；所以应选择D两位是2a，a是无效的数字，所以只将2赋给变量a1，字符\'a\'通过后续的getchar函数将其赋给变量c2，再接下来调用scanf函数将输入的三位数赋给整型变量a2，则a2的值为345。所以正确答案是A。',1,1,0.5),('3-17','若变量a、i已正确定义，且i已正确赋值，合法的语句是','B',3,'A是关系表达式，不是C语句；C中的a++是表达式不能出现在赋值运算符的左边，故是非法的；D中int不可作为函数名，应写为(int)i的形式；B是将i的值增1，是合法的，所以应选择B。',1,1,0.5),('3-18','<html>若有如下程序<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbspint y = 3, x = 3, z = 1;<br/>&nbsp;&nbsp;&nbsp;printf （\'\'%d %d\\n \'\', (++x, y++), z+2);<br/>&nbsp;&nbsp;&nbsp;}<br/></html>','D',3,'逗号表达式的求值顺序是从左向右依次计算用逗号分隔的各表达式的值，最后一个表达式的值就是整个逗号表达式的值，所以(++x, y++)的值将是y++，因为是先输出y的值，再将y增1，所以首先输出3，再输出z+2的值，即3；所以应选择D。',1,1,0.5),('3-19','下面正确的字符常量是','C',3,'C语言中的字符常量必须由单引号括起来的字符。A表示的是一字符串常量，不是字符常量；B中右边不是单引号的错误的；D中单引号之间没有任何字符也是非法的；C表示的是W字符，是正确的，所以应选择C。',1,1,0.5),('3-2','下面四个选项中，均是不合法的用户标识符的选项是(     )。','C',3,'根据C语言中对标识符的规定：A中的A、P、O是合法的，do是关键字，非法；B中的la0、_A是合法的，float是关键字，非法；C中b-a非法，因“-”不是标识符中的有效字符，sizeof和int均是关键字，非法；D中的_123、temp是合法的，int是关键字，非法。故只有C全错，所以选择C。',1,1,0.5),('3-20','在C语言中（以16位PC为例），5种基本数据类型的存储空间长度的排列顺序为','A',3,'在16位的PC中，char类型占1个字节，int占2各字节，long int占4个字节，float占4个字节，double占8个字节。所以正确答案是A。',1,1,0.5),('3-21','假设所有变量均为整型，则表达式（a=2, b=5, b++, a+b）的值是','B',3,'逗号表达式的求值顺序是从左向右依次计算用逗号分隔的各表达式的值，最后一个表达式的值就是整个逗号表达式的值。所以表达式最后的值是a+b，但经过前面的计算，此时a的值为2，b的值是6，所以最后的结果是8，应选择B。',1,1,0.5),('3-22','以下正确的叙述是 ','D',3,'在C语言程序中，每行中可以写多行语句，故A的说法错误；整型数可以赋值给实型变量，其实是将整数转换成实型数后再赋值给实型变量的，并不是实型变量中允许存放整型数，故B也是错误的；在C语言程序中，整型数据可以准确的表示，但实数因有其精度的限制，不可能准确无误地表示，故C也是错误的；%运算符只能用于整数的运算，所以D是正确的',1,1,0.5),('3-23','假定x和y为double型，则表达式x=2，y=x+3/2的值是 ','D',3,'逗号表达式的值是最后一个表达式的值，即y=x+3/2的值，因x的值是2.000000,3/2的值是1，所以y的值是3.000000，应选择D。',1,1,0.5),('3-24','<html>void main (  )<br/>&nbsp;&nbsp; &nbsp;(<br/>&nbsp;&nbsp; &nbsp;int a = 3;<br/>&nbsp;&nbsp;&nbsp;printf （\'\'%d\\n \'\', (a+=a-=a*a) ）;<br/>&nbsp;&nbsp;&nbsp;)<br/></html>','D',3,'a+=a-=a*a等价于a=a+(a=a-a*a)，即先计算a=a-a*a，所以此时a的值为3-3*3=-6，再计算-6+(-6)=-12赋值给a，所以a的值为-12，也就是整个表达式的值，所以应选择D。',1,1,0.5),('3-25','在16位C编译系统上，若定义long a;，则能给a赋40000的正确语句是','D',3,'在16位C编译系统上，A、B、C中的计算结果是40000，是一整型数据，即占16个二进制位，其16位二进制补码为 1001 1100 0100 0000，最高为1，其实表示一负数，则赋给变量a后其值为 1111 1111 1111 1111 1001 1100 0100 0000；表示的值为-25536，而不是40000，所以A、B、C都是错误的；对于D来说，因为4000L*10L=4000L是一长整型数，没有超出长整型数的表示范围，所以是正确的，结果应选择D。',1,1,0.5),('3-26','若变量a是int类型，并执行了语句a=\'A\'+1.6;，则正确的叙述是','D',3,'a=\'A\'+1.6：其功能是将字符\'A\'的ASCII的值加上1.6，然后将运算结果的整数部分赋值给整型变量a，所以a的值是字符\'A\'的ASCII值加上1。正确答案为D。',1,1,0.5),('3-27','语句printf(\'\'a\\bre\\\'hi\\\'y\\\\\\bou\\n\'\')；的输出结果是','C',3,'首先要明确该字符串中包含的转义字符，\'\'a\\bre\\\'hi\\\'\'y\\\\\\bou\\n\'\'中的转义字符(带下划线的部分)共有6个，其中\'\\b\'是退格符，输出时将光标往左边回退一个位置，\'\'\\\'\'为单引号字符，\'\\\\\'为\\字符，\'\\n\'为回车换行符。所以显示的结果为C。',1,1,0.5),('3-28','<html>void main (  )<br/>&nbsp;&nbsp; &nbsp;{<br/>&nbsp;&nbsp; &nbsp;int x = \'\'f\'\';<br/>&nbsp;&nbsp; &nbsp;printf {（\'\'%c\\n \'\',  \'\'A\'\'+ (x-\'\'a\'\'+1) ）}; <br/>&nbsp;&nbsp; &nbsp;}<br/></html>','A',3,'因为x和\'\'f\'\'，所以x-\'\'a\'\'+1的值为6，\'\'A\'\'+6对应的是\'\'G\'\'，所以输出的结果是A',1,1,0.5),('3-29','<html>void main (  )<br/>&nbsp;&nbsp; &nbsp;{char x = 0xFFFF;<br/>&nbsp;&nbsp; &nbsp; printf （\'\'%d\\n \'\',  x--);<br/>&nbsp;&nbsp; &nbsp;}</html>','C',3,'因为x是字符型，所以将0xFFFF赋值给x，x的值为0xFF，因为数据在内存中是其补码表示的，0xFF的真值是-1，所以显示的结果是-1，即正确答案为C。',1,1,0.5),('3-3','下面四个选项中，均是合法整型常量的选项是(     )。','A',3,'A中160是十进制数，—0xffff是十六进制数，011是八进制数，均合法；B中01a非法，因为a不是八进制数码；C中986,012非法，不能包含“，”，0668非法，因为8不是八进制数码；D中0x非法，因为后面没有有效的十六进制数码。所以选择A。',1,1,0.5),('3-30','已知：int x = 1，y=-1;，则语句 printf（\'\'%d\\n \'\',  (x--& ++y) ）;的输出结果是','B',3,'x--& ++y是将x的值与++y的值0进行按位与操作，其结果显然是0，所以正确答案为B。',1,1,0.5),('3-4','下面四个选项中，均是不合法的浮点数的选项是(     )。','B',3,'C语言中的浮点数有两种形式，一种为十进制小数形式，一种为指数形式，其一般形式为a E n ，a为十进制数，n为十进制整数，都不可省略。A中e3非法，因为只有阶码3没有尾数，其余两数都是合法的浮点数；B中123是整数，不是浮点数，2e4.2阶码部分4.2是浮点数，不是整数，故是非法的，.e5尾数部分不能只有小数点，也是非法的；C中的三个数均是合法的浮点数；D中的.234和le3也是合法的，只有—e3非法。所以选择B。',1,1,0.5),('3-5','下面四个选项中，均是不合法的转义字符的选项是(     )。','B',3,'A中均为合法的转义字符；B中\'\\1011\'的\\后面多于3位八进制数是非法的，\'\\\'不能标识\\字符，是非法的，\'\\ab\'的\\后面漏掉了x是非法的；C中\'\\011\'是合法的；D中\'\\101\'是合法的；故都不合法的只有B，所以选择B。',1,1,0.5),('3-6','下面四个选项中，均是正确的数值常量或者字符常量的选项是(     )。','D',3,'A中0f、8.9e是非法的数值常量；B中\'\'a\'\'是字符串常量，是非法的数值常量或者字符常量；C中0a是非法的数值常量；D中均是合法的数值常量；所以选择D。',1,1,0.5),('3-7','<html>下面程序段输出结果是(     )。int i = 5, k; <br/>k = (++i) + (++i) + (i++);<br/>printf (\'\'%d,%d \'\',  k,  i);<br/></html>','B',3,'k=(++i)+(++i)+(i++)表达式中，\'\'++\'\'号在i前面的有两个，所以在计算k之前，i要先增两次，即i变为7，然后再讲3个7相加，使得k的值为21，表达式中\'\'++\'\'号在i后面的有1个，所以得出k的值以后i又增1次变为8。所以正确答案为B。',1,1,0.5),('3-8','<html>下面程序段输出结果是(     )。short int i = 32769; <br/>k = (++i) + (++i) + (i++);<br/>printf (\'\'%d\\n \'\',  i);</html>','C',3,'因为(32769)10=(1000 0000 0000 0001)2，所以i得值在内存中的补码形式表示为',1,1,0.5),('3-9','若有说明语句:char c=\'\\72\'；则变量c (     )。','A',3,'因为\'\\72\'是转义字符，表示其ASCII码为八进制数72的字符，即\'：\'字符，所以正确答案是A。',1,1,0.5),('4-1','<html>在16位C编译系统上，下列程序执行后的输出结果是(     )。void main (  )<br/>&nbsp; &nbsp;&nbsp;{ int a = -32769; printf （\'\'%8U\\n \'\',  a); <br/>&nbsp; &nbsp;&nbsp; }<br/>&nbsp; &nbsp;&nbsp;</html>','B',4,'格式字符必须小写，题中的\'\'%8U \'\'不会当作格式控制符，而是原样输出，变量a将没有对应的格式说明，也不会输出。所以正确答案为B(注意：在VC下结果为U)。',1,1,0.5),('4-10','<html>执行下面程序时，假设用户输入为1□22□333，则ch1、ch2、ch3的值为(     )。char ch1, ch2, ch3;<br/>scanf （\'\'%1c%2c%3c\'\',  &ch1,  &ch2,  &ch3);<br/></html> ','B',4,'当格式控制符是%nc，空格和转义字符均作为有效字符被输入，将把n个字符中的第一个字符赋值给相应的字符变量，其余字符被舍弃。所以ch1的值为\'1\'，ch2将是□2的第一个空格符\' \'，ch3为2□3的第一个字符\'2\'，所以正确答案是B。',1,1,0.5),('4-11','已知：int x,y; double z;，以下语句中错误的函数调用是(     )。','D',4,'scanf中的格式控制符不能指明浮点数的精度，D中%6.2f是错误的。所以应选择D。',1,1,0.5),('4-12','<html>已有如下定义和输入语句，若要求a1、a2，c1、c2的值分别为10、20、A和B，当从第一列开始输入数据时，正确的数据输入方式是(      )。int a1、a2；char c1、c2;<br/>scanf （\'\'%d%c%d%c\'\',  &a1,  &c1,  &a2,  &c2);<br/></html>','C',4,'scanf用于输入整数时，当遇到非数字字符结束，此时非数字字符将存入键盘缓冲区，如果接着读入字符，将从键盘缓冲区中读取该字符。对于C的输入，10后面是字符\'A\',则将10给a1，\'A\'九赋给c1，20赋给a2，\'B\'赋给c2。所以正确的输入方法是C。',1,1,0.5),('4-13','<html>阅读以下程序，当输入数据的形式为25,13,10↙,正确的输出结果为(     )。void main (  )<br/>&nbsp,&nbsp,&nbsp; {<br/>&nbsp,&nbsp,&nbsp;int  x, y, z;<br/>&nbsp,&nbsp,&nbsp;scanf  (”%d%d%d”,  &x,  &y,  &z);<br/>&nbsp,&nbsp,&nbsp;printf （\'\'x+y+z= %d\\n \'\', x+y+z);<br/>&nbsp,&nbsp,&nbsp; }<br/>&nbsp,&nbsp,&nbsp;</html>','D',4,'当一次scanf调用需要输入多个数据项时，如果前面数据的输入遇到非法字符，并且输入的非法字符不是格式控制字符串中的常规字符，那么，这种非法输入将影响后面数据的输入，导致数据输入失败。当输入为25,13,10时，a的值是25，y和z的值将无法预测，所以x+y+z的值是无法确定的。故正确答案是D。',1,1,0.5),('4-14','已有定义int x; float y;且执行scanf  (”%3d%f”,  &x,  &y);语句时，假设输入数据为12345□678↙，则x、y、z的值分别为 (      )。','D',4,'因为%3d，所以输入中的前3位数123将赋给x，输入中后面的45将赋给y，因为45后键入了空格使得后面的输入无效，又因y是浮点数，所以y的值应为45.000000。故正确答案是D。',1,1,0.5),('4-15','<html>void main (   )<br/>&nbsp;&nbsp; &nbsp; {<br/>&nbsp;&nbsp; &nbsp;char c1, c2;<br/>&nbsp;&nbsp; &nbsp;int  a1, a2;<br/>&nbsp;&nbsp; &nbsp;c1=getchar (  );<br/>&nbsp;&nbsp; &nbsp;scanf  (”%2d”,  &a1);<br/>&nbsp;&nbsp; &nbsp;c2=getchar (  );<br/>&nbsp;&nbsp; &nbsp;scanf  (”%3d”,  &a2);<br/>&nbsp;&nbsp; &nbsp;printf （\'\'%d, %d, %c, %c\\n \'\', a1, a2, c1, c2); }</html>','A',4,'通过调用getchar函数将输入的第一个字符赋给c1，所以c1的值是字符”1”，接下来调用scanf函数将输入的两位数赋给整型变量a1，但此时输入的两位是2a，a是无效的数字，所以只将2赋给变量a1，字符\'a\'通过后续的getchar函数将其赋给变量c2，再接下来调用scanf函数将输入的三位数赋给整型变量a2，则a2的值为345。所以正确答案是A。',1,1,0.5),('4-2','<html>下列程序段执行后的输出结果是(     )(□表示一个空格)。 int a = 3366;<br/> printf （\'\'|%-08d| \'\',  a); <br/></html>','C',4,'%-08d表示输出占8个字符的位置，并且左对齐，所以正确的答案是C。',1,1,0.5),('4-3','<html>以下程序的输出结果是(      )。void main (  )<br/>&nbsp,&nbsp,&nbsp;{<br/>&nbsp, &nbsp,&nbsp;printf （\'\'s1 = |%15s|  s2 = |%-5s| \'\', \'\'chinabeijing \'\',  \'\'chi\'\');<br/>&nbsp,&nbsp,&nbsp; }<br/>&nbsp, &nbsp,&nbsp;</html>','D',4,'%15s表示输出占15个空格的位置，并且右对齐，左边多余的位置补空格，因为\'\'chinabeijing \'\'包含12个字符，所以输出时，左边要补上3个空格，%-5s表示输出占5个空格的位置，并且左对齐，右边多余的位置补空格，因为\'\'chi\'\'包含3个字符，所以输出时，右边要补上2个字符。所以正确的答案是D。',1,1,0.5),('4-4','<html>在16位C编译系统上，以下程序的输出结果是(     )。void main (  )<br/>&nbsp,&nbsp,&nbsp;{<br/>&nbsp,&nbsp,&nbsp;long y = -43456;<br/>&nbsp,&nbsp,&nbsp; printf （\'\'y = |%-81d|  y = |%-081d|  y = |%081d|  y = |%+81d|“, y, y, y, y);<br/>}</html>','C',4,'%-81d表示输出占8个空格的位置，左对齐，右边多余的位置补空格，故第一个y的输出为：|-43456□□|。%-081d等价于%-81d，因为不可能在右边空位上补0，所以第二个y的输出也为：|-43456□□|。%081d表示输出占8个空格的位置，右对齐，左边多余的位置补0，所以第三个y的输出为：|-0043456|。%+81d表示输出占8个空格的位置，右对齐，左边多余的位置补空格，必须输出正负号，所以第四个y的输出为：|□□-43456|。正确答案应为C。',1,1,0.5),('4-5','<html>在16位C编译系统上，以下程序的输出结果是(     )。void main (  )<br/>&nbsp,&nbsp,&nbsp; {<br/>&nbsp,&nbsp,&nbsp;int y = 2456;<br/>&nbsp,&nbsp,&nbsp;printf （\'\'y = |%3o|  y = |%8o|  y = |%#8o|  y = |%08o| \'\', y, y, y, y);<br/>&nbsp,&nbsp,&nbsp; }<br/>&nbsp,&nbsp,&nbsp;</html>','B',4,'因为y的输出是以其八进制的形式输出，(2456)10=(4630)8，所以A和C是错误的，%3o表示以八进制数形式输出，占3个空格的位置，右对齐，左边边多余的位置补空格，但实际数据的宽度为4大于规定的宽度，所以此时按实际宽度输出，故第一个y的输出为|4630|。%8o和%3o的差别就在于输出占8个空格的位置，所以左边要补4个空格，故第二个y的输出也为|□□□□4630|。%#8o和%8o的差别只是输出时必须输出八进制前导0，所以第三个y的输出为|□□□04630|。%08o和%8o的差别只是输出时左边多余的位置补0，所以第四个y的输出为|00004630|。正确答案应为B。',1,1,0.5),('4-6','若有说明语句：int a;float b;，以下输入语句正确的是(     )。','C',4,'因为a是int型，所以格式控制符应为%d，而f是float型，所以格式控制符应为%f。故正确答案应为C。',1,1,0.5),('4-7','<html>执行下面程序段，给x、y赋值时，不能作为数据分隔符的是(     )。int x, y;<br/>scanf （\'%d%d\'\', &x, &y);<br/></html>','D',4,'如果相邻两个格式控制符之间，不指定数据分隔符(如逗号、冒号等)，则相应的两个输入数据之间，至少用一个空格分隔，或者用Tab键分隔，或者输入一个数据后，按回车键，然后再输入下一个数据。而逗号不能作为数据分隔符，应选择D。',1,1,0.5),('4-8','<html>执行下面程序时，欲将25和2.5分别赋给a和b，正确的输入方法是(     )。int a;<br/>float b;<br/>scanf （\'\'a =%d, b =%f\'\',  &a,  &b);<br/></html>','C',4,'格式控制符串中出现的常规字符(包括转义字符)，务必原样输入。所以正确答案为C。',1,1,0.5),('4-9','若有说明语句：int a,b;，用户的输入为111222333，结果a的值为111，b的值为333，那么以下输入正确的语句是(     )','B',4,'当格式控制符串中含有抑制符\'*\'时，表示本输入项对应的数据读入后，不赋给相应的变量(该变量由下一个格式指示符输入)。所以A的结果将使a的值不确定(因为%3c与a的类型不匹配)，b的值为333；C的结果将使a的值为111，b的值为222；D的结果将使a的值为111，b的值为233；B的结果将使a的值为111，b的值为333，中间输入的222不赋给任何变量(%*3c的作用)；所以正确答案是B。',1,1,0.5),('5-1','与y=(x>0?1:x<0?-1:0);的功能相同的if语句是（    ）。','A',5,'表达式(x>0?1:x<0?-1:0)的功能是：如果x大于0则返回1，否则如果小于0则返回-1，再否则(即等于0)返回0。B、C、D均是错误的，只有A正确。',1,1,0.5),('5-10','<html>若有如下程序，该程序的输出结果是（  ）。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;float x=2.0,y;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if(x<0.0) y=0.0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;else if (x<10.0)  y =1.0/x;<br/>&nbsp;&nbsp;&nbsp;&nbsp;else y =1.0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (“%f\\n”,y);<br/>}<html><br/>','C',5,'逻辑与（&&）运算具有左结合性，所以先求（m=a>b）的值，因关系运算符的优先级高于赋值运算符，所以该表达式应理解为将a>b比较的结果0赋值给m,整个表达式的值也就是0.对于逻辑与运算特点，左边表达式的值如果为假，则右边表达式不参与运算，所以n的值不变。故正确答案是C。',1,1,0.5),('5-11','以下错误的if语句时（   ）。','C',5,'答案C中，语句printf(“%d”,x)后面掉了分号（；）。所以应选择C。',1,1,0.5),('5-12','<html>以下程序的输出（   ）。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  a =20 , b=30, c=40;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (a>b)  a=b;<br/>&nbsp;&nbsp;&nbsp;&nbsp;b=c  ;c=a ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf  ( “a=%d, b=%d, c=%d” ,a, b ,c);<br/>}<html><br/>','A',5,'a = b , b = c ;应看作是一条语句，因a>b为假，所以语句 a = b ,b = c ;不执行，c = a ;语句则总是要执行的，此时a、b 的值不变（分别为20、30），c的值为a的值，故正确答案为A。',1,1,0.5),('5-13','对于条件表达式（k）?(i++):(i- -);l来说，其中的表达式K等价于（   ）。','C',5,'对于该条件表达式应理解为：k 为真时返回 i + + ,否则返回i - - 。在C语言中表达式的值非0表示真，为0表示假，所以k为真应表示为k!=0.故正确答案为C。',1,1,0.5),('5-14','<html>下面程序运行结果为（   ）。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char c = ‘a’;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (‘a’<c<=’z’)  printf  (“LON”);<br/>&nbsp;&nbsp;&nbsp;&nbsp;else  printf (“UP”);<br/>}<html><br/>','A',5,'关系运算符具有左结合性，所以表达式（‘a’< c <=‘z’）将先求‘a’<c的值，即为0（假），再求0<=’z’的值，即为1（真），所以执行if后面的语句printf(“LOW”):故正确答案为A。',1,1,0.5),('5-15','<html>对下述程序，正确的判断是（  ）。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a ,b ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;scanf (“%d,%d”,&a,&b);<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (a>b) a= b; b = a ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;else a + +;b ++;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (“%d,%d”,a,b);<br/>}<html><br/>','A',5,'在if 和else之间如果有多条语句，则必须适用复合语句，否则程序语法错误。该程序if和else之间有两条语句a= b;b =a；，但没有加{  }，是错误的。故正确答案为A。',1,1,0.5),('5-16','<html>已知intx=10,y=20,z=30;以下语句执行后x，y，z的值是（    ）。<br/>if （x>y）<br/>&nbsp;&nbsp;&nbsp;&nbsp;z=x;x=y;y=z;<html><br/>','B',5,'语句z=x;是否执行与if后面的条件是否为真有关，条件为真该语句执行，为假不执行。而语句x=y;y=z;则与if后面的条件无关，总要执行，因x=10,y=20所以x>y为假，则语句z=x;不执行，即z的值不变，语句x=y;y=z;执行后，x的值为y的值，y的值为z的值。故正确答案是B。',1,1,0.5),('5-17','<html>请阅读以下程序：<br/>main(  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a = 5 ,b = 0, c = 0 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if(a=b+c)   printf (“***\\n”);<br/>&nbsp;&nbsp;&nbsp;&nbsp;else     printf (“$$$\\n”);<br/>}<html><br/>以上程序（ ）。','D',5,'if后面的表达式可以是任何类型的表达式，当然可以是赋值表达式，所以答案A和B 是错误的。因赋值表达式的值为0（即为假），所以执行else后的语句，输出$$$,故正确答案是D。',1,1,0.5),('5-18','<html>请阅读以下程序，其运行结果是（   ）。<br/>void main  (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char c = ‘A’;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (‘0’<=c<=’9’)    printf  (“yes”)；<br/>&nbsp;&nbsp;&nbsp;&nbsp;else  printf (“NO”);<br/>}<html><br/>','A',5,'关系运算符具有左结合性，所以（‘0’<=c<=’9’）等价于（（‘0’<=c）<=’9’）.因c=’A’,所以（‘0’<=c）的值为真，即为1,1<=’9’的值为真，即为1，所以执行if后面的语句，输出YES。故正确答案是A。',1,1,0.5),('5-19','<html>当a=1,b=3,c=5,d=4时，执行完下面一段程序后x的值是（     ）。<br/>if（a<b）<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (c<d)  x=1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a<c)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(b<d)  x=2;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else x=3;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else  x= 6;<br/>&nbsp;&nbsp;&nbsp;&nbsp;else x=7;<html><br/>','B',5,'因a<b为真，执行if(c<d),但c<d为假，故执行if（a<c）,a<c为真，执行if（b<d）,b<d为真，执行x=2,所以x的值是2.正确答案为B。',1,1,0.5),('5-2','多重if_else语句嵌套使用时，寻找与else配对的if方法是（ ）。','D',5,'C语言规定，在缺省{  }时，else总是和它上面离它最近的未配对的if配对。所以正确答案是D。',1,1,0.5),('5-20','已知x=43,ch=’A’,y=0;则表达式（x>=y&&ch<’B’&&!y）的值是（     ）。','C',5,'表达式x>=y&&ch<’B’&&!y等价于（x>=y）&&(ch<’B’)&&(!y),(x>=y)的值为真，（ch<’B’）的值也为真（因‘A’<’B’）,而y=0,所以（！y）的值也为真，所以整个表达式的值为真，即为1。正确答案为C。',1,1,0.5),('5-21','<html>有如下程序，正确的输出结果是（    ）。<br/>void main （  ）{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a =15 ,b =21,m =0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;switch (a % 3)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;case 0 :m++; break;<br/>&nbsp;&nbsp;&nbsp;&nbsp;case 1:m++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;switch (b % 2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;default:m++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;case 0 :m++;break;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf  (“%d\\n”,m);<br/>}<html><br/>','A',5,'a的值为15，则a%3的值为0，所以执行case 0 后面的语句，即m增1后，m的值为1，执行break子句退出switch。故正确答案为A。',1,1,0.5),('5-22','<html>阅读以下程序，如果从键盘上输入5，则正确的输出结果是（   ）。<br/>void main （  ）<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int x;<br/>&nbsp;&nbsp;&nbsp;&nbsp;scanf (“%d”,&x);<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (x - - <5)  printf  (“%d”, x );<br/>&nbsp;&nbsp;&nbsp;&nbsp;else  printf (“%d”,x++);<br/>}<html><br/>','B',5,'表达式x - - <5是先进行x<5的比较，然后x减1，因x的开始值为5，所以表达式的值为假，执行else后的语句，但此时x的值减1后变为4，执行语句printf(“%d”,x++)；是先输出x的值即4，然后将x增1.故正确答案为B',1,1,0.5),('5-23','若a、b、c1、c2、x、y均是整型变量，正确的switch语句是（   ）。','A',5,'答案B中case3后跟分号是错误的；答案C中switch后面的表达式忘了小括号，并且break子句后也忘了分号，是错误的；答案D中的前面两个break子句后忘了分号，也是错误的。故正确答案为A。',1,1,0.5),('5-24','对 if 语句中表达式的类型，下面正确的描述是（ ）。','D',5,'if 语句中的表达式不局限于哪种类型的表达式，只要表达式非零时，表达式的值就为真，否则就是假。所以正确答案是D。',1,1,0.5),('5-3','逻辑运算符两侧运算对象的数据类型(   )。','D',5,'逻辑运算符两侧运算对象的值如果是0，则表示假，非0就表示真，不管其类型是什么。故正确答案为D。',1,1,0.5),('5-4','以下关于运算符优先顺序的描述中正确的是(   )。','C',5,'算术运算符的优先级高于关系运算符，关系运算符的优先级高于逻辑运算符，逻辑运算符的优先级则高于赋值运算符。例如，a=x+y>2&&x+y<8;等价于a=(((x+y)>2&&((x+y)<8));,故正确答案为C。',1,1,0.5),('5-5','下列运算符中优先级最高的是（ ）。','B',5,'算术运算符的优先级高于关系运算符，关系运算符的优先级高于逻辑运算符。+是算术运算符，<和！=是关系运算符，&&是逻辑运算符。故正确答案为B。',1,1,0.5),('5-6','若希望当A的值为奇数时，表达式的值为“真”，A的值为偶数时，表达式的值为“假”，则以下不能满足要求的表达式是（  ）。','C',5,'当A为奇数时，A%2的值为1（真），所以A%2==1为真，！（A%2==0）也为真，而！（A%2）的值却为假。当A为偶数时，！（A%2）的值却为真，其余均为假。故不能满足要求的表达式是C。',1,1,0.5),('5-7','判断char型变量c1是否为小写字母的正确表达式是（ ）。','D',5,'字符的比较其实是比较它们的ASCⅡ码值，在ASCⅡ码表中，小写字母字符‘a’~’z’是连续的，其ASCⅡ码值是逐渐增1，故判断c1是否为小写字母，应判断c1是否大于或者等于字符‘a’,并且小于或者等于字符‘z’。故正确答案是D。',1,1,0.5),('5-8','若有定义：float w； int  a, b；则合法的switch语句时（ ）。','B',5,'switch后面的“表达式”，可以是int、char和枚举型中的一种，不能是float型变量，所以A是非法的；case后面必须是“常量表达式”，表达式中不能包含变量，所以C也是非法的；D中switch后的表达式加了分号（；）是非法的。所以正确答案是B。',1,1,0.5),('5-9','<html>有如下程序，该程序的输出结果是（  ）。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int x= 1 ,a=0,b=0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;switch (x) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;case 0: b++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;case 1 :a++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;case 2: a++;b++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(“a=%d,b=%d\\n”,a,b);<br/>}<br/></html>','A',5,'因x的值是1，所以case1后面的语句a++;执行，a的值增1，但因后面无break子句，case2后的语句也要执行，a的值再增1，b的值增1，所以a和b的值最后分别为2和1.故正确答案是A。',1,1,0.5),('6-1','语句while(!E);中的表达式！E等价于（ ） 。','A',6,'对于while(!E)来讲，只有E为 0条件才为真。所以其等价于while(E==0).故正确答案是A。',1,1,0.5),('6-10','<html>设有程序段：<br/>int k = 10 ; <br/>&nbsp;&nbsp;&nbsp;&nbsp;while (k = 0)  k = k – 1 ;<br/></html>则下面描述中正确的是 （    ） 。','C',6,'因while后面的表达式是赋值表达式，其值为0（即为假），所以循环体内的语句不可能执行。故正确答案是C。',1,1,0.5),('6-11','<html>设有以下程序段：<br/>int x = 0 , s = 0 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;while (!x ! = 0 ) s += + + x;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf （“%d”,s）<br/></html>则（    ）。','B',6,'x的初始值为0，所以！x为1，！x!=0条件成立，进入循环体，先将x增1，x的值变为1，然后将s的值与x的值相加的结果（即为1）赋值给s,s的值变为1，再对while后的条件进行判断，此时x为1，所以！x为0，则！x！=0条件不成立，循环结束，输出s的值为1。故正确答案是B。',1,1,0.5),('6-12','<html>下面程序段的运行结果是（    ） 。<br/>a = 1; b = 2 ; c = 2 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;while (a<b<c)  ( t =a ; a = b ; b = t ; c - - ;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf （“%d,%d,%d”,a , b , c ）;<br/></html>','A',6,'第一次循环时，条件(a<b<c)相当于（1<2<2）,其值为真（左结合性），进入循环体，先将a、b的值交换（t = a ; a = b; b = t ;）,然后将c的值减1，此时a=2,b =1,c =1.第二次循环时，条件(a<b<c)相当于（2<1<1），其值为真，进入循环体，a、b的值交换，c减1，此时a=1,b = 2,c = 0。.第三次循环时，条件(a<b<c)相当于（1<2<0），其值为假，循环结束。所以正确答案是A。',1,1,0.5),('6-13','<html>下面程序段的运行结果是 （  ）。<br/>x = y = 0 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;while (x<15) y ++, x + = + + y;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (“%d,%d”,y,x);<br/></html>','D',6,'第一次循环，x为0，x<15为真，进入循环体，y的值变为2，x的值变为2；第二次循环， x<15为真，进入循环体，y的值变为4，x的值变为6；第三次循环，x<15为真，进入循环体，y的值变为6，x的值变为12；第四次循环，x<15为真，进入循环体，y的值变为8，x的值变为20；第五次循环，x<15为假，退出循环。故正确答案是D。',1,1,0.5),('6-14','<html>以下程序段（    ）。<br/>x=-1;&nbsp;&nbsp;&nbsp;&nbsp;do  ( x = x * x; ) while ( ! x);<br/></html>','C',6,'do-while 循环结构中的循环体至少要执行一次，执行循环体中的语句后，x的值为1，再对while后的表达式进行计算，因！x的值为0，所以循环结束，即整个循环只执行了一次。故正确答案是C。',1,1,0.5),('6-15','<html>以下for循环的执行次数是（    ）。<br/>for (x = 0 , y = 0; ( y = 123 ) && (x<4);x++)；<br/></html>','C',6,'决定for循环次数的表达式是（y=123）&&(x<4),而（y=123）表达式恒为真，所以该表达式等价于（x<4），即x的值决定循环的次数，因每次循环后x增1,所以当x增到4时，（x<4）就为假，循环结束。所以循环次数是4次。故正确答案是C。',1,1,0.5),('6-16','<html>设有程序段：<br/>t=0；<br/>&nbsp;&nbsp;&nbsp;&nbsp;while (printf （“*”）) （t + + ;if (t<3) break ;）<br/></html>下面描述正确的是（     ）。','B',6,'因printf（“*”）函数调用的返回值是字符串中字符的个数，即为1.所以while后面的条件恒为真，所以循环控制表法师与‘0’是等价的。正确答案是B。',1,1,0.5),('6-17','以下描述中正确的是（    ）。','C',6,'do-while循环中循环体语句如果多余一条则可使用复合语句；do-while循环由do开始，用while结束，while不能省略，在while（表达式）后面必须写分号；为了保证循环正常结束，通常在循环体中对循环控制变量进行更改，以使得while后面的值变为零。所以正确答案是C。',1,1,0.5),('6-18','<html>有以下程序段：<br/>int n = 0 , p ;<br/>&nbsp;&nbsp;&nbsp;&nbsp; do (scanf (“%d”,&p);n++;) while (p! =12345 && n<3)；<br/></html>此处do-while 循环的结束条件是（     ）。','D',6,'while后面的条件为真是循环继续的条件，要想循环结束，则while后面的条件必须为假，即原条件求反，也就是（p==12345||n>=3）。所以正确答案是D。',1,1,0.5),('6-19','<html>以下程序的输出结果是（    ）。<br/>void mainv（  ）<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a , b ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for （a=1, b = 1 ; a < =100;a ++）<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (b>=10) break ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (b% 3 = = 1) {b + = 3 ; continue ;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (“%d\\n”,a);<br/>}<br/></html>','D',6,'第一次循环：a = 1, b = 1, a < = 100为真，进入循环，使得b=4；第二次循环：a = 2, b = 4, a < = 100为真，进入循环，使得b=7；第三次循环：a = 3, b = 7, a < = 100为真，进入循环，使得b=10；第四次循环：a = 4, b = 10, a < = 100为真，进入循环，此时因b>=10成立，break退出循环执行printf语句，所以显示a的值为4。正确答案是D。',1,1,0.5),('6-2','对for（表达式1；；表达式3）可理解为（ ）。','B',6,'表达式2的省略意味着其值恒为真。故正确答案是B。',1,1,0.5),('6-20','<html>以下程序中，while循环的循环次数是（     ）。<br/>int  i=0<br/>&nbsp;&nbsp;&nbsp;&nbsp;while (i<10)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;if(i<1) continue;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if(i==5) break ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;i++<br/>}<br/></html>','D',6,'因i的初始值为0，所以while后面的条件为真，进入循环体，if后面的条件i<1成立，执行cintinue语句，继续对while后的条件进行判断，因为此时对变量i的值没有任何变化，所以条件总是成立，循环将无限进行下去。所以正确答案是D。',1,1,0.5),('6-3','以下不是无限循环的语句为（ ）。','A',6,'对于A来讲，条件判断x>++y的值为假（因x的值为1，++y的值为1），循环结束，对于B和D来讲，因为表达式2省略了，则相当于恒为真，所以是死循环，对于C来说，while后表达式的值为1，恒为真，也是死循环。故正确答案是A。',1,1,0.5),('6-4','下面有关for循环的正确描述是（ ）。','D',6,'for循环常用语循环次数已知的循环中，但也可以用于循环次数未知的循环中；for循环是先判断表达式，根据表达式的值来决定是否循环；在for循环中如果要中途退出循环，可以使用break语句来实现。所以A、B、C都是错误的，正确答案是D。',1,1,0.5),('6-6','<html>下面程序的功能是把316表示为两个加数的和，使两个加数分别能被13和11整除，请选择填空。<br/>#include <stdio .h><br/>&nbsp;&nbsp;&nbsp;&nbsp;void main (   )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int i= 0， j , k ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;do { i+ +;k = 316 – 13 *i;} while ( (   ) )<br/>&nbsp;&nbsp;&nbsp;&nbsp;j = k / 11;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf ( “316 = 13 * % d + 11 * % d ” , i, j );<br/>}<br/></html>','B',6,'程序的设计思想是每次讲316减去13的倍数，然后判断其差值是否被11整除，如果不能整除，则继续循环，直到能被11整除为止。所以正确答案为B。',1,1,0.5),('6-7','<html>下面程序的运行结果是 (   )。<br/>#include <stdio .h>void main (   )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  y  =  10 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;do  (y==;) while (- - y);<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf （ “%d\\n”,y- - ）;<br/>}<br/></html>','D',6,'do – while 循环是直到 y 变为 0 时才结束，所以输出的结果是 0 ，当然，最后y的值是 – 1 。故正确答案为D。',1,1,0.5),('6-8','若运行以下程序时，从键盘输入ADescriptor↙(↙表示回车)，则下面程序的运行结果是（   ） 。若运行以下程序时，从键盘输入ADescriptor↙(↙表示回车)，则下面程序的运行结果是（   )。<html><br/>#include <stdio .h><br/>&nbsp;&nbsp;&nbsp;&nbsp;void main (   )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char  c ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;int v0 = o , v1 = 0 , v2 = 0 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;  do (<br/>&nbsp;&nbsp;&nbsp;&nbsp;switch ( c =getchar( )) （<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ‘a’ : case ‘A’:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ‘e’ : case ‘E’:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ‘i’ : case ‘I’:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ‘o’ : case ‘O’:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ‘u’ : case ‘U’:vi += 1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;)while (c! = ‘\\n’);<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (“v0 = %d , v1 = %d , v2 = %d\\n”,v0 , v1 , v2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<html><br/>','D',6,'因case后面都没有break子句，所以进入case后，除了v1增 1 以外，还要执行default后的语句，v0 和v2都要增1。输入的字符串ADescriptor↙中A、e、i、o各出现一次，所以v1要增加4次，其值为4，字符串中字符总数为12（包含回车符），所以v0和v2要增加12次，其值分别为12、12.故正确答案为 D。',1,1,0.5),('6-9','<html>下面程序的运行结果是（   ）。<br/>#include <stdio .h><br/>&nbsp;&nbsp;&nbsp;&nbsp;void main (   )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a = 1 ,b = 10 ;<br/>&nbsp;&nbsp;&nbsp;&nbsp;do <br/>&nbsp;&nbsp;&nbsp;&nbsp;{b - = a ; a + +; } while {b - - < 0 };<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf （”a = %d, b = %d\\n”, a,b） ;<br/>}<br/></html>','B',6,'因a、b的初始值分别为1和10， 进入循环体后，b 的值为10 – 1 ， 即为 9 ， a增 1 变为 2 ，再对while 后面的表达式进行检测，此时先判断b<0为假，循环结束，再将b减 1 ，即b变为 8 。 故正确答案为B。',1,1,0.5),('7-1','在C语言中，引用数组元素时，其数组下标的数据类型允许是（ ）。','C',7,'数组元素引用时，其数组下标的数据类型只能是整型常量或者整型表达式。所以正确答案是C。',1,1,0.5),('7-10','判断字符串s1是否大于字符串s2，应当使用(   )。','D',7,'两个字符串s1和s2比较大小应使用库函数strcmp(s1,s2)，其返回值如果大于0，则表示字符串s1大于字符串s2；小于0，则表示字符串s1小于字符串s2；等于0，则表示两符串相等。所以正确答案是D。',1,1,0.5),('7-11','<html>给出以下定义，则正确的叙述为(    )。<br/>char x[ ] = \'\'abcdefg\'\';<br/>&nbsp;&nbsp;&nbsp;&nbsp;char y[ ] = {\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\'}<br/>;</html>','C',7,'对数组x赋值一个字符串，其数组的大小应为字符串的长度加1(字符串结尾符\'\'\\0\'\')，所以数组x的大小是8，而数组y赋初值的元素个数是7，所以数组y的大小也就是7。所以正确答案是C。',1,1,0.5),('7-12','<html>以下程序的输出结果是(    )。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char st[20] = \'\'hello\\0\\t\\\\\\\'\';<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf  {%d %d \\n\'\', strlen (st), sizeof (st)};<br/>}<br/></html>','B',7,'计算字符串的长度是从第一个字符开始一直计数到第一个\'\\0\'为止(不包含\'\\0\')，对于st存放的字符串，第6个元素就是\'\\0\'，所以字符串的长度是5，但数组st的大小与赋值的字符串无关，是其定义的大小20。所以正确答案是B。',1,1,0.5),('7-13','<html>定义如下变量和数组：<br/>int k;<br/>&nbsp;&nbsp;&nbsp;&nbsp;int a[3][3]={1,2,3,4,5,6,7,8,9};<html><br/>则下面语句的输出结果是(    )。<br/>for {k = 0; k < 3; k++}  printf  {\'\'%d \'\', a[k][2-k]};<br/></html>','A',7,'k=0时，输出a[0][2]，即为3；k=1时，输出a[1][1]，即为5；k=2时，输出a[2][0]，即为7。所以正确答案是A。',1,1,0.5),('7-14','<html>当执行下面的程序时，如果输入ABC，则输出结果是(    )。<br/>#include \"stdio .h\"<br/>&nbsp;&nbsp;&nbsp;&nbsp;#include \"string .h\"<br/>&nbsp;&nbsp;&nbsp;&nbsp;void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char ss[10] = \"1,2,3,4,5\";<br/>&nbsp;&nbsp;&nbsp;&nbsp;gets (ss); strcat (ss, \"6789\") ; printf  {\"%s\\n\", ss};<br/>=}<br/></html>','A',7,'字符数组ss的大小为10，执行get(ss);后，等待键盘输入一字符串，由于输入的是ABC，因此此时ss中存放的字符串是\'\'ABC\'\'，再通过strcat库函数将字符串\'\'6789\'\'连接到ss当前的字符串\'\'ABC\'\'之后，这样ss中保存的字符串变为\'\'ABC6789\'\'。所以正确答案是A。',1,1,0.5),('7-15','<html>以下程序的输出结果是(    )。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char w[ ][10] = {\'\'ABCD\'\', \'\'EFGH\'\', \'\'IJKL\'\', \'\'MNOP\'\'}, k;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for {k = 1; k < 3; k++}  printf  {\'\'%s\\n \'\', w[k] };<br/>}<br/></html>','D',7,'从for循环的次数可知，要显示两个字符串，一个是w[1]，即为EFGH，另一个是w[2]，即为IJKL。所以正确答案是D。',1,1,0.5),('7-16','<html>以下程序的输出结果是(    )。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char arr[2][4];<br/>&nbsp;&nbsp;&nbsp;&nbsp;strcpy {arr[0], \'\'you\'\'}; strcpy {arr[1], \'\'me\'\'};<br/>&nbsp;&nbsp;&nbsp;&nbsp;arr[0][3] = \'&\';<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf  {\'\'%s \\n \'\', arr};<br/>}<br/></html>','A',7,'因为arr是一个2行4列的二维数组，每一行可以存放最多三个字符的字符串。执行strcpy {arr[0], \'\'you\'\'};后则将字符串\'\'you\'\'放置在数组arr的第一行上，即a[0][0] =\'y\'，a[0][1]=\'o\'，a[0][2]=\'u\'，a[0][3]=\'\\o\'(字符串结尾符)，执行strcpy {arr[1], \'\'me\'\'};后则将字符串\'\'me\'\'放置在数组arr的第二行上，即a[1][0] =\'m\'，a[1][1]=\'e\'， a[1][2]=\'\\o\'(字符串结尾符)，由于二维数组在内存中是以行序存放的，执行arr[0][3] = \'&\';后，第一行与第二行将视为一个字符串\'\' you&me \'\'，而数组名则是该字符串的首地址。所以正确答案是A。',1,1,0.5),('7-17','已知：char str1[8], str2[8]={ \'\'good\'\'};则在程序中不能将字符数组str2赋值给str1的语句是（    ）。','A',7,'数组名是一地址常量，数组名之间是不能彼此赋值的，所以A是错误的。故选择答案是A。',1,1,0.5),('7-18','<html>下面程序段的运行结果是(     )。 （注：□代表空格）<br/>char c[5] = {\'a\', \'b\', \'\\0\', \'c\', \'\\0\'};<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf  {\'\'%s \'\', c};<br/></html>','B',7,'printf函数是用来输出字符数组c所存放的字符串，输出字符串中的字符将从第一个字符开始直到遇到\'\\0\'为止。所以输出的结果是ab。故正确答案是B。',1,1,0.5),('7-19','<html>下面程序段的运行结果是(     )。 （注：□代表空格）<br/>char a[7] = \'\'abcde\'\'; char b[4] = \'\'ABC\'\';<br/>&nbsp;&nbsp;&nbsp;&nbsp;strcpy (a, b);  printf  {\'\'%c \'\', a[4]};<br/></html>','C',7,'执行strcpy (a, b)后，将把字符串\'\'ABC\'\'复制到数组a中，但是要注意复制的字符串只覆盖原来数组a中的前4个元素(字符串\'\'ABC\'\'的长度加1)，第5个元素a[4]的值没变，仍是字符\'e\'。故正确答案是C。',1,1,0.5),('7-2','若有说明：int a[10];，则对数组元素的正确引用是（ ）。','D',7,'因为定义的数组包含10个元素，对数组元素引用的下标是从0～9。显然a[10]超出了数组的范围，A是错误的引用。因数组下标的数据类型必须是整型，所以B是错误的。数组引用应使用中括号，小括号是非法的，所以C也是错误的。故正确答案是D，即引用a[0]。',1,1,0.5),('7-20','<html>下面程序的运行结果是(     )。<br/>void main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char ch[7] = {\'\'65ab21\'\'};<br/>&nbsp;&nbsp;&nbsp;&nbsp;int i, s = 0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for {i = 0; ch[i] >= \'0\' && ch[i] <= \'9\'; i += 2}<br/>&nbsp;&nbsp;&nbsp;&nbsp;s = 10 * s+ ch[i] - \'0\';<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf  {\'\'%d \\n \'\', s};<br/>}<br/></html>','C',7,'进入for循环时，i的值为0，表达式（ch[i] >= \'0\' && ch[i] <= \'9\'）是用来检测ch[i]是否为数字字符，因为ch[0]是\'6\'，所以表达式为真，进入循环体中执行s = 10 * s+ ch[i] - \'0\';语句，该语句的功能就是将数字串转换成相应的整数，因s的初值为0，所以s的结果为6。语句执行完后，再将i增2，再判断ch[2]是否为数字字符，因ch[2]是\'a\'，表达式为假，循环退出。所以s的值输出为6。故正确答案是C。',1,1,0.5),('7-3','设有数组定义：char array[]=\'\' China\'\';，则数组array所占的空间为(   )。','C',7,'因为字符串\'\' China\'\'中有5个字符，要占5个字节的内存单元，再加上字符串的结尾符\' \\n\'，所以整个数组应占用6个字节的内存单元。正确答案是C。',1,1,0.5),('7-4','若二维数组a有m列，则在 a[i][j]前的元素个数为(  )。','B',7,'对于元素a[i][j]，其前面有i行，本行前面有j列(注意：行、列均是从0开始)，所以其前元素的个数为i * m + j。正确答案是B。',1,1,0.5),('7-5','若有说明：int a[][3]={1,2,3,4,5,6,7};，则a数组第一维的大小是(  )。','B',7,'因为二维数组a每一行有3个元素，而赋初始值有7个元素，所以其行数应为3。正确答案是B。',1,1,0.5),('7-6','以下不正确的定义语句是(   )。','B',7,'对数组赋初值时，初值的个数不能超过数组的大小。因为B中定义的数组y其大小为5，而赋初值时包含了6个值，所以B定义是非法的。',1,1,0.5),('7-7','以下不能对二维数组a进行正确初始化的语句是(   )。','C',7,'C中定义的二维数组是2行3列的数组，但赋初值时给了3行的数据，超出了数组的范围，是非法的。所以答案是C。',1,1,0.5),('7-8','以下能对二维数组a进行正确初始化的语句是(   )。','B',7,'定义二维数组并赋初值时，可以省略第一维的大小，但不能省略第二维的大小，所以A是错误的；对于C来说，定义的数组A是2行4列的数组，但赋初值却包含了3行，所以是错误的；D中初值列表中有一行是空的，这在C语言中是不允许的，所以也是错误的；B定义了2行3列的二维数组并对其赋值，是正确的，所以正确答案是B。',1,1,0.5),('7-9','以下不能正确进行字符串赋初值的语句是(   )。','A',7,'因为A中定义的字符型数组str其大小为5，即只能存放5个字符，但字符串\'\'good!\'\'对str赋初值时，要包含字符串结尾符\'\'\\0\'\'，则字符个数是6，超出了str的表示范围，所以A是错误。',1,1,0.5),('8-1','以下正确的说法是（ ）。','B',8,'用户若需要调用标准库函数，调用前只需将包含该库函数的头文件用#include预处理命令包含进来即可，而不必去重新定义，如果重新定义，该函数将失去原有的意义，所以正确答案是B。',1,1,0.5),('8-10','C语言规定，函数返回值的类型是由（  ）。','D',8,'函数的返回值的类型是由定义该函数时所指定的数据类型来决定的。所以正确答案是D。',1,1,0.5),('8-11','C语言规定：简单变量作为实参时，他和对应形参之间的数据传递方式是（ ）。','B',8,'简单变量作为实参时，将把该变量所占内存单元的值传递给形参，实参和形参各占不同的内存单元，传递完后，实参和形参不再有任何联系，所以这种传递方式也叫做单向值传递方式。所以正确答案是B。',1,1,0.5),('8-12','以下只有在使用时才为该类型变量分配内存的存储类说明是（ ）。','B',8,'C语言中变量的存储类型分为两种：动态存储和静态存储，其存储类型说明符有auto、static、register和extern，其中auto和register所说明的变量是动态存储类型的变量，该类变量只有在使用时系统才为其分配内存单元。而static和extern所说明的变量是静态存储类型的变量，程序运行时系统就会为该类变量分配存储单元。所以正确答案是B。',1,1,0.5),('8-13','以下叙述中不正确的是（  ）。','D',8,'在一个函数内的复合语句中定义的变量时局部变量，其作用范围是从定义处到复合语句的结束，也就是只在本复合语句内有效。所以D的叙述式错误的。应选择D。',1,1,0.5),('8-14','<html>已有如下数组定义和f函数调用语句，则在f函数的说明中，对形参数组array的正确定义方式为（      ）。<br/>int  a[3][4];<br/>&nbsp;&nbsp;&nbsp;&nbsp;f  (a);<br/></html>','C',8,'当用二维数组作为形参时，第一维的大小可以省略，但第二维的大小事不能省略的，必须和实参数组第二维的大小一致。所以正确答案是C。',1,1,0.5),('8-15','<html>有以下程序，程序运行后的输出结果是（       ）。<br/>float  fun(int x,int y)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{  return(x+y);}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  main()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  a=2,b=5,c=8;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(＂%3.0f\\n＂,fun((int)fun(a+c,b),a-c));<br/>}<br/></html>','B',8,'对函数调用fun（（int）fun（a+c，b），a-c），首先调用fun（a+c，b），得到的值是15.000000，因为fun函数的返回值是float型，然后通过对fun（a+c，b）进行强制类型转换将得到的结果转换为整型数15，在调用fun（15，a-c），则得到的值为9.000000.因为printf中输出格式控制符是%3.0f，即不输出小数位，所以输出将是9.所以正确答案是B。',1,1,0.5),('8-16','<html>下列程序执行后的输出结果是（      ）。<br/>void  funcl (int  i)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(＂%c＂,st[i]);<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (i<3) (i+=2;func2 (i);)<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  func2(int  i)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(＂%c＂,st [i])<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (i<3) (i+=2;funcl (i);)<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  main ()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  i=0;  funcl (i); printf(＂\\n＂);<br/>}<br/></html>','C',8,'首先从main函数开始，i=0，调用funcl函数，显示字符str[0]（即h），因i>3成立，i+=2后，i=2，在调用func2，显示字符str[2]（即1），因i<3成立，i+=2后，i=4，又调用funcl，显示str[4]（即o），此时i<3不成立，返回到func2，再又返回到funcl，最后返回到main函数。所以输出结果是hlo，正确答案是C。',1,1,0.5),('8-17','<html>有以下程序，程序运行后的输出结果是（     ）。<br/>int  f （int  n）<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if （n= =1）  return  1；<br/>&nbsp;&nbsp;&nbsp;&nbsp;else  return  f （n-1）+1；<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  main （）<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  i, j=0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for(i=1;i<3;i++)   j+=f(i);<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(＂%d\\n＂,j);<br/>}<br/></html>','B',8,'首先了解函数f的功能：f(1)，f(2)=f(1)+1=2，f(2)+1=3，…，f（n）=f（n-1）+1，所以f的功能其实就是返回实参的值。再来执行main函数中的for循环，i=1时，j+=f(1)后，j的值为1，i++后，i<3成立，继续执行j+=f(2)，则j的值为1+2=3，所以正确答案为B。',1,1,0.5),('8-18','<html>以下程序的输出结果是（    ）。<br/>void  incre(  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  x=3;<br/>&nbsp;&nbsp;&nbsp;&nbsp;void main( )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  i;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i<x;i++) incre ();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  incre()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;staic  int  x=1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;x*=x+1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(＂%d＂,x);<br/>}<br/></html>','C',8,'因为在函数incre内部定义了一静态局部变量x，尽管与全局变量x同名，但它们占用各自不同的内存单元，对于静态变量x来说，因为它的生存期与程序相同，所以每次调用后其值将长期保留，其初始值是当程序运行时赋值一次，以后调用不在赋初始值。所以第一次调用输出2，第二次调用就输出6（2*3），故正确答案为C。',1,1,0.5),('8-19','<html>以下程序的输出的结果是（    ）。<br/>int  a=3；<br/>&nbsp;&nbsp;&nbsp;&nbsp;main ( )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  a =0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;(int  a =5; s+=a++;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;s  +=a++;  printf(＂%d\\n＂,s)<br/>}<br/></html>','A',8,'复合语句中定义的变量如果与全局变量同名，那么在复合语句中对该变量的引用是指复合语句中定义的变量，而不是全局变量。所以，程序中复合语句内s+=a++，执行的结果将使得s的值为s=s+5=0+5=5，复合语句执行完后，再执行s+=a++，此时的a是指全局变量，s的值将是s=s+3=5+3=8.所以正确答案为A。',1,1,0.5),('8-2','以下不正确的说法是（ ）。','B',8,'函数的实参可以是常量、变量或者表达式，但形参只能是变量，不可以是常量或者表达式，所以B是不正确的说法。故应选择B。',1,1,0.5),('8-20','<html>以下程序的输出的结果是（     ）。<br/>void  f (int  a [ ],  int  I, int  j){<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  t;<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (i<j) (t=a[i];  a [i];  a [j]=t;  f()a, i+1, j-1)；）<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  main  ( )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  i, a[5]=(1,2,3,4,5);<br/>&nbsp;&nbsp;&nbsp;&nbsp;f (a,0,4);<br/>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i<5;i++)  printf(＂%d,＂,a[i]);<br/>}<br/></html>','A',8,'函数f的功能是：如果数组a的下标i比下标j小，就将a[i]与a[j]交换，然后进一步判断i+1与j-1的大小，如果i+1比j-1小，再将a[i+1]与a[j-1]交换，直到前者的下标不小于后者的下标为止。即函数f的功能就是将数组元素a[i]到a[j]之间元素进行交换。所以函数调用f（a，0,4）其结果就是将a[0]与a[4]交换，a[1]到a[3]交换，所以交换后数组a中的元素为5 4 3 2 1.所以正确答案为A。',1,1,0.5),('8-3','以下正确的函数定义形式是（ ）。','A',8,'函数定义时每个形参都必须指明数据类型符，形参之间必须以逗号隔开，所以B和D是错误的，另外，函数定义时末尾不能带分号，只有函数说明时才带分号，所以C也是错误的。故正确答案是A。',1,1,0.5),('8-4','以下正确的说法是（ ）。','C',8,'C语言中，定义函数时，形参的类型说明必须放在形参的前面，不能放在函数体内：return后边的值可以是常量或者表达式；如果形参与实参类型不一致，应以形参类型为准；所以答案A、B、D都是不正确的说法。正确答案是C。',1,1,0.5),('8-5','在C语言中，函数的隐含存储类别是（  ）。','C',8,'如果在函数定义中没有说明extern或者static，则隐含为extern。正确答案是C。',1,1,0.5),('8-6','凡是函数中未指定存储类别的局部变量，其隐含的存储类别为（ ）。','A',8,'C语言程序中，某函数内定义的局部变量，如果未指定存储类型，则默认为自动（auto）型。所以正确答案是A。',1,1,0.5),('8-7','若使用一维数组名作函数实参，则以下正确的说法是（  ）。','A',8,'当用数组名作为函数的实参时，在主调函数中必须说明该数组的大小，因为数组定义必须要指明数组的大小，以方便系统为其分配内存单元。所以正确答案是A。',1,1,0.5),('8-8','若用数组名作为函数的实参，传递给形参的是（  ）。','A',8,'因为数组名是该数组所占内存单元的首地址，是一地址常量，当其作为函数的实参时，传递给形参的显然是数组的首地址。所以正确答案是A。',1,1,0.5),('8-9','函数调用不可以（  ）。','D',8,'数调用可以出现在C语言执行语句中，也可以出现在表达式中，甚至还可以作为一个函数的实参，但不可作为函数的形参。所以正确答案是D。',1,1,0.5),('9-1','下面正确进行字符串赋值操作的是（         ）。','C',9,'C语言中，字符串必须是以‘\\0’结尾。在答案A中，s定义为5个元素的字符型数组，即最多能存放5个字符，字符串结尾符‘\\0’无法存放，故A是错误的字符串赋值；答案B对数组赋值没错，但同A一样，没有字符串结尾符‘\\0’，所以也是错误的；答案D是“野指针”赋值，是错误的；而对于答案C，先定义字符指针s，而后将字符串“ABCDE”的首地址赋值给指针变量s，是正确的赋值。所以正确答案是C。',1,1,0.5),('9-10','若有定义：inta[8]；则以下表达式中不能代表数组元素a[1]的地址的是（  ）。','C',9,'&a[0]+1表示元素a[0]的地址加1，也就是a[1]的地址；&a[1]当然表示元素a[1]的地址；a+1表示数组a的首地址（即a[0]的地址）家1，也是a[1]的地址；而&a[0]++包括有对&a[0]的赋值运算，本身是非法的。所以选择答案是C。',1,1,0.5),('9-11','若有以下语句且0<=k<6，则正确表示数组元素地址的语句是（       ）。<html><br/>static int x[  ]  =  {1,  3,  5,  7,  9,  11},*ptr  =  x,  k;<br/><html>','C',9,'x是数组名，是一地址常量，不能赋值，所以答案A是错误的；ptr是指针变量，&ptr表示该指针变量所占内存单元的地址，所以答案B也是错误的；&（x+1）是非法的表达式，故D也是错误的；&ptr[k]表示数组元素x[k]的地址，它等价于&（*（ptr+k））。所以正确答案是C。',1,1,0.5),('9-12','设已有定义：char* st=\"how are you\";下列程序段中正确的是（       ）。','A',9,'a是数组名，是一地址常量，++a是非法的，所以答案B错误；因为数组a的大小为11，执行strcpy（a,st）；st字符串的结尾符‘\\0’无法存放在数组a中，所以答案C也是错误的；答案D中定义数组a时未指定大小，所以也是错误的；对于答案A来说，执行strcpy（p=a+1，&st[4]）；首先将数组a的第二个元素a[1]的地址赋给指针变量p，然后将st第5个元素开始知道字符串结束为止的字符复制到p所指向的内存单元中，所以选择答案是A。',1,1,0.5),('9-13','<html>下面程序段的运行结果是（     ）。<br/>char  s[ ]=\"abcdefgh\",*p =s;<br/>&nbsp;&nbsp;&nbsp;&nbsp;P  += 3;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%d\\n\", strlen  (strcpy(p, \"ABCD\")));</html>','C',9,'strcpy（p，＂ABCD＂）的功能是将字符串＂ABCD＂复制到指针变量p所指向的内存单元中，其返回值是指针p所指内存单元的地址，然后p所指字符串的长度，显然是4，所以正确答案是C。',1,1,0.5),('9-14','<html>下面程序段中，fo r循环的执行次数是（      ）。<br/>char *s =\"\\ta\\018bc\";<br/>for(; *s  != ‘\\0’; s++)   print (\"*\");</html>','C',9,'for循环的执行次数其实就是字符串s的长度，在s所指向的字符串中，‘\\t’是转义字符，‘\\01’也是一个转义字符，这样的字符串的长度就是6。所以正确答案是C。',1,1,0.5),('9-15','<html>以下程序的输出结果是（       ）。<br/>void main()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char *p=\"abcdefgh\", *r;<br/>&nbsp;&nbsp;&nbsp;&nbsp;long *q;<br/>&nbsp;&nbsp;&nbsp;&nbsp;q=(long*)p;<br/>&nbsp;&nbsp;&nbsp;&nbsp;q++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;r=(char*)q;<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%s\\n\",r);<br/>}</html>','D',9,'执行q=（long*）p；后，q指向字符串的第一个元素‘a’，q++；执行后，q指向字符串的第5个元素‘e’，因为q是long型指针变量，增1相当于将q往后移动4个字符的位置，然后执行r=（char*）q；则r指向字符‘e’，这时再输出r所指向的字符串就是＂efgh＂了，所以正确答案是D。',1,2,0.5),('9-16','设有语句int  array[3][4];则在下面几种引用下标为i和j的数组元素的方法中，不正确的引用方式是（     ）。','D',9,'因为array是一个二维数组，*（array+i）是列地址，等价于array[i]，而*（array[i]+j）则是第i行中的第j个元素，即array[i][j]，所以答案A、B、C都是正确的；而答案D只是对列地址的引用，不是对数组元素的引用，所以选择答案是D。',1,1,0.5),('9-17','<html>以下程序的运行结果是（       ）。<br/>void  sub (int  x,  int  y, int  *z)<br/>(  *z =y –x ;  )<br/>void  main ( )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int  a, b, c;<br/>&nbsp;&nbsp;&nbsp;&nbsp;sub (10, 5, &a);<br/>&nbsp;&nbsp;&nbsp;&nbsp;sub (7, a, &b);<br/>&nbsp;&nbsp;&nbsp;&nbsp;sub (a, b,&c);<br/>&nbsp;&nbsp;&nbsp;&nbsp;printrf (＂%d,  %d,  %d\\n＂, a,  b,  c);<br/>}</html>','B',9,'第一次调用函数sub（10,5，&a）；后，a的值为5—10= —5，第二次调用函数sub（7，a，&b）；后，b的值为a—7= —5—7= —12，第三次调用函数sub（a，b，&c）；c的值为b—a= —12—（—5）= —7，所以选择答案是B。',1,1,0.5),('9-18','在说明语句int*f（）；中，标识符f代表的是（        ）。','D',9,'指向整型数据的指针变量应说明为int *f；，指向一维数组的行指针应说明为int（*f）[5]，指向函数的指针变量应说明为int（*f）（）；所以选择答案是D。',1,1,0.5),('9-19','<html>若有以下说明和定义，在必要的赋值之和，对fun函数的正确调用语句是（    ）。<br/> int  fun (int *c)   (…)<br/>void  main (  )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int (*a) (int  *) = fum, *b ( ), w [10],  c;<br/>&nbsp;&nbsp;&nbsp;&nbsp;…<br/>}</html>','B',9,'在答案A中，a（w）调用正确，但将其返回值赋值给a是错误的，因为回值是整型数，而a是一函数指针，所以答案A是错误的。在答案C中，因b是一个返回值为整型数，而a是一函数指针，所以答案A是错误的。在答案C中，因b是一个返回值为整型数指针的函数，*b（w）本省就是错误的；在答案D中，b后面省掉了括号，因为b是函数，故也是错误的；而对于答案B来说，因为a指向了函数fum，所以它等价于fun（&c）的调用，是正确的。所以正确答案是B。',1,1,0.5),('9-2','对于基类型相同的两个指针变量之间，不能进行的运算是（       ）。','C',9,'C语言中，对于基类型相同的两个指针变量之间可以进行大小比较、赋值及减法运算，但加法运算没有意义。所以应选择C。',1,1,0.5),('9-20','若指针p已正确定义，要使p指向两个连续的短整型动态存储单元，不正确的语句是（       ）。','A',9,'因为短整型数据在内存中占两个字节，而函数calloc也是动态内存分配的函数，第一个参数表示分配的单元个数，第二个参数表示每个分配单元的大小，所以答案B、C、D都是正确的；而答案A中，2*应放在malloc里面，是错误的。所以选择答案是A。',1,1,0.5),('9-21','<html>若有以下定义和语句，则对s数组元素的正确引用形式式（     ）。<br/>int  s [4] [5],(*ps) [5];<br/>ps =s;<br/></html>','C',9,'ps是一指向二维数组s的指针，ps+1表示指向数组s第2行首地址的指针；*（ps+3）表示数组s第4行的首地址；*（ps+1）+3表示数组s第2行第4列元素的地址，答案A、B、D都不是对数组元素的正确引用。所以正确答案是C。',1,1,0.5),('9-22','<html>有以下程序，若从键盘输入abc def↙，则输出结果是（       ）。<br/>void  main (  )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char *p,  *q;<br/>&nbsp;&nbsp;&nbsp;&nbsp;p= (char *) malloc(sizeof(char)*20);<br/>&nbsp;&nbsp;&nbsp;&nbsp; q = p;<br/>&nbsp;&nbsp;&nbsp;&nbsp;scanf (＂%s%s＂, p, q);<br/>&nbsp;&nbsp;&nbsp;&nbsp; printf (＂%s %s\\n＂,p ,q);<br/>}</html>','A',9,'因为指针p和q都是指向动态分配的20个字节的内存单元，当使用scanf来读取输入的字符串到该内存块时，首先将abc存入到指针p所指的内存块，输入中的空格符，表示字符串输入结束，下一字符串def将存入到q所指的内存块，即原先的字符串abc将被覆盖掉。所以输出的结构就应是def def。 即正确答案是A。',1,1,0.5),('9-23','<html>有以下程序，程序运行后的输出结果是（       ）。<br/>void  ss  (char *s,  char  t)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;while (*s)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;if(*s = = t )  *s = t – ‘a’ + ‘A’;<br/>&nbsp;&nbsp;&nbsp;&nbsp;s++;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void  main (  )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;char  strl [100] = ＂abcddfefdbd＂, c = ‘d’<br/>&nbsp;&nbsp;&nbsp;&nbsp;ss (strl ,  c);printf (＂%s\\n＂,  strl);  <br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></html>','B',9,'函数ss的功能就是将字符串s中的所有字符为t的字符替换为大写字符。对于主函数中的函数ss的调用，就是将字符串 strl中的小些字符‘d’替换成大写字符‘D’。所以正确答案是B。',1,1,0.5),('9-24','<html>若定义了以下函数：<br/>void  f (  )<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;*p = (double *) malloc (10*sizeof(double));<br/>&nbsp;&nbsp;&nbsp;&nbsp;…<br/>}<br/></html>P是该函数的形参，要求通过p把动态分配存储单元的地址传回主调函数，则形参p的正确定义应当是（       ）。','C',9,'动态内存分配函数调用的返回值是所分配内存区域的首地址，而赋值语句的左边是*p，则说明*p是一地址变量，即一级指针变量，所以p就应是二级指针变量，又因为malloc前面有强制类型转换符double*，因此指针变量应为double型。故正确答案是C。',1,1,0.5),('9-25','<html>阅读程序，下面程序的输出结果是（       ）。假设可执行文件的文件名为prop.exe，运行时键入的命令行为prog-386net↙。<br/>#include<stdio.h><br/>void  main  (int  argc ,  char *argv[ ])<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int i;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i < argc; i++)<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf (＂%s＂ ,argv [i]);<br/>}<br/></html>','D',9,'程序的功能就是将命令行参数输出，因为命令行参数是3，所以输出的结果应是3个字符串，并且执行文件输入时没有带 .exe，所以输出第一个命令形参数就应是prg，而不是prop.exe。故正确答案是D。',1,1,0.5),('9-3','下面说明不正确的是（    ）。','D',9,'语言中，在定义字符型数组时，可以直接用字符串对数组赋初值，只要数组定义的大小能容纳字符串中的字符即可，另外，对定义的字符型指针变量可以将字符串常量对其赋值，但数组名是地址常量，是不能用字符串对其赋值得。所以正确答案是D。',1,1,0.5),('9-4','<html>若有下面的程序段，则下列叙述正确的是（     ）。<br/> Char  s[  ] =＂china＂; <br/> char *p; p = s;</html>','D',9,'s是数组名，是一地址常量，对s不能进行运算，而p是指针变量，可进行赋值等运算，所以答案A是错误的；数组s中的内容是一字符串，而指针变量p中的内容是地址，两者不可能相等，故答案B是错误的；数组s的大小为6（包含‘\\0’），而p所指向的字符串长度是5（不包含‘\\0’），所以C也是错误的。P指向数组s的第一个元素，所以*p与s[0]的值都是为字符‘c’，所以正确答案是D。',1,1,0.5),('9-5','若有说明：int*p,m=5,n;则以下正确的程序段是（       ）。','D',9,'因p是指针变量，在scanf中不能再使用&p或者*p来接收键盘的输入值，应直接用p即可，所以答案A和B都是错误的；而C中*p=n；是“野指针”赋值，因p未指向某一内存单元，所以答案C也是错误的；答案D中是将变量n的地址给指针变量p，然后再把m的值赋值给p所指向的内存单元，也就是赋值给n，是正确的。所以正确答案是D。',1,1,0.5),('9-6','若有语句int*point,a=4;和point=&a；下面均代表地址的一组选项是（       ）。','D',9,'a是整形变量不是地址，所以答案A是错误的：p是指针变量，其所指向内存单元的内容*point是整型值，也不是地址，所以答案B和C也是错误的；对于答案D来说，&a指变量a的地址，&*point表示point所指向内存单元值得地址，也就是point。所以正确答案是D。',1,1,0.5),('9-7','变量的指针，其含义是指该变量的（      ）。','B',9,'指针即地址，变量的指针也就是该变量在内存中的地址。所以正确答案是B。',1,1,0.5),('9-8','已有定义int k=2；int*ptrl，*ptr2；且ptrl和ptr2均已指向变量k，下面不能正确执行的赋值语句是（      ）。','B',9,'因ptr2和ptr2均是指向变量k的指针变量，指针变量只能存放地址，所以ptr2=k；这种将变量k的值（整型值2）赋值给指针变量显然是非法的。所以选择答案是B。',1,1,0.5),('9-9','若有说明：int i, j=2, *p=&i;, 则能完成i=j赋值功能的语句是（           ）。','B',9,'因为指针变量p指向了变量i，所以*p就是变量i，而*&j表示变量j的地址所指向内存单元的内容，故*p=*&j；完成的功能就是i=j；所以正确答案是B。',1,1,0.5);
/*!40000 ALTER TABLE `selection` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `id` varchar(10) NOT NULL,
  `pass` varchar(45) DEFAULT NULL,
  `times` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('10094189','10094189',0),('10102215','1',10),('10112041','10112041',0),('10112555','10112555',0),('10120090','10120090',0),('10120122','10120122',0),('10120123','10120123',0),('10120136','10120136',0),('10121931','10121931',0),('10121942','10121942',0),('10122010','10122010',0),('10122050','10122050',0),('10123060','10123060',0),('10129011','10129011',0),('10130988','10130988',0),('10131446','10131446',0),('10131447','10131447',0),('10131448','10131448',0),('10131449','10131449',0),('10131450','10131450',0),('10131451','10131451',0),('10131452','10131452',0),('10131453','10131453',0),('10131454','10131454',0),('10131455','10131455',0),('10131456','10131456',0),('10131457','10131457',0),('10131458','10131458',0),('10131459','10131459',0),('10131460','10131460',0),('10131461','10131461',0),('10131462','10131462',0),('10131463','10131463',0),('10131464','10131464',0),('10131465','10131465',0),('10131466','10131466',0),('10131467','10131467',0),('10131468','10131468',0),('10131469','10131469',0),('10131470','10131470',0),('10131471','10131471',0),('10131472','10131472',0),('10131473','10131473',0),('10131474','10131474',0),('10131475','10131475',0),('10131476','10131476',0),('10131477','10131477',0),('10131478','10131478',0),('10131479','10131479',0),('10131480','10131480',0),('10131481','10131481',0),('10131482','10131482',0),('10131483','10131483',0),('10131484','10131484',0),('10131485','10131485',0),('10131486','10131486',0),('10131487','10131487',0),('10131488','10131488',0),('10131489','10131489',0),('10131490','10131490',0),('10131491','10131491',0),('10131492','10131492',0),('10131493','10131493',0),('10131494','10131494',0),('10131495','10131495',0),('10131496','10131496',0),('10131497','10131497',0),('10131498','10131498',0),('10131499','10131499',0),('10131500','10131500',0),('10131501','10131501',0),('10131502','10131502',0),('10131503','10131503',0),('10131504','10131504',0),('10131714','10131714',0),('10131715','10131715',0),('10131716','10131716',0),('10131717','10131717',0),('10131718','10131718',0),('10131719','10131719',0),('10131720','10131720',0),('10131721','10131721',0),('10131722','10131722',0),('10131723','10131723',0),('10131724','10131724',0),('10131725','10131725',0),('10131726','10131726',0),('10131727','10131727',0),('10131728','10131728',0),('10131729','10131729',0),('10131730','10131730',0),('10131731','10131731',0),('10131732','10131732',0),('10131733','10131733',0),('10131734','10131734',0),('10131735','10131735',0),('10131736','10131736',0),('10131737','10131737',0),('10131738','10131738',0),('10131739','10131739',0),('10131740','10131740',0),('10131741','10131741',0),('10131742','10131742',0),('10131743','10131743',0),('10131744','10131744',0),('10131745','10131745',0),('10131746','10131746',0),('10131747','10131747',0),('10131748','10131748',0),('10131749','10131749',0),('10131750','10131750',0),('10131751','10131751',0),('10131752','10131752',0),('10131753','10131753',0),('10131754','10131754',0),('10131755','10131755',0),('10131756','10131756',0),('10131757','10131757',0),('10131758','10131758',0),('10131759','10131759',0),('10131760','10131760',0),('10131761','10131761',0),('10131762','10131762',0),('10131763','10131763',0),('10131764','10131764',0),('10131765','10131765',0),('10131766','10131766',0),('10131767','10131767',0),('10131768','10131768',0),('10131769','10131769',0),('10131770','10131770',0),('10131771','10131771',0),('10131772','10131772',0),('10131773','10131773',0),('10131774','10131774',0),('10131775','10131775',0),('10131776','10131776',0),('10131777','10131777',0),('10131778','10131778',0),('10131779','10131779',0),('10131780','10131780',0),('10131781','10131781',0),('10131782','10131782',0),('10131783','10131783',0),('10131784','10131784',0),('10131785','10131785',0),('10131786','10131786',0),('10131787','10131787',0),('10131788','10131788',0),('10131789','10131789',0),('10131790','10131790',0),('10131791','10131791',0),('10131792','10131792',0),('10131793','10131793',0),('10131794','10131794',0),('10131795','10131795',0),('10131796','10131796',0),('10131797','10131797',0),('10131798','10131798',0),('10131799','10131799',0),('10131800','10131800',0),('10131801','10131801',0),('10136004','10136004',0),('10136036','10136036',0),('10138023','10138023',0),('14130008','14130008',0),('14130009','14130009',0);
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping routines for database 'model_test'
--
/*!50003 DROP FUNCTION IF EXISTS `no_zero` */;
/*!50003 SET @saved_cs_client      = @@character_set_client */ ;
/*!50003 SET @saved_cs_results     = @@character_set_results */ ;
/*!50003 SET @saved_col_connection = @@collation_connection */ ;
/*!50003 SET character_set_client  = utf8 */ ;
/*!50003 SET character_set_results = utf8 */ ;
/*!50003 SET collation_connection  = utf8_general_ci */ ;
/*!50003 SET @saved_sql_mode       = @@sql_mode */ ;
/*!50003 SET sql_mode              = 'STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION' */ ;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` FUNCTION `no_zero`(
	str varchar(20),
	split varchar(10)
) RETURNS varchar(20) CHARSET utf8
begin
	declare location int;
	declare former varchar(10);
	declare latter varchar(10);
	set location=instr(str, split);
	set former=substring(str, 1, location-1);
	set latter=substring(str from location+1);
	if(strcmp(substring(latter,1,1),'0')=0) then
		set latter=substring(latter from 2);
	end if;
	return concat(former, split, latter);
end ;;
DELIMITER ;
/*!50003 SET sql_mode              = @saved_sql_mode */ ;
/*!50003 SET character_set_client  = @saved_cs_client */ ;
/*!50003 SET character_set_results = @saved_cs_results */ ;
/*!50003 SET collation_connection  = @saved_col_connection */ ;
/*!50003 DROP PROCEDURE IF EXISTS `formatExpla` */;
/*!50003 SET @saved_cs_client      = @@character_set_client */ ;
/*!50003 SET @saved_cs_results     = @@character_set_results */ ;
/*!50003 SET @saved_col_connection = @@collation_connection */ ;
/*!50003 SET character_set_client  = utf8 */ ;
/*!50003 SET character_set_results = utf8 */ ;
/*!50003 SET collation_connection  = utf8_general_ci */ ;
/*!50003 SET @saved_sql_mode       = @@sql_mode */ ;
/*!50003 SET sql_mode              = 'STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION' */ ;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `formatExpla`()
BEGIN
	declare done int default 0;
	declare _expla text;
	declare cur cursor for select explanation from selection;
	declare continue handler for not found set done=1;
	open cur;
	cursor_loop: loop
		fetch cur into _expla;
		if done=1 then
			leave cursor_loop;
		end if;
		if strcmp(left(_expla, 1), '`')=0 then
			update selection set explanation=substring(_expla from 2) where explanation=_expla;
		end if;
	end loop cursor_loop;
END ;;
DELIMITER ;
/*!50003 SET sql_mode              = @saved_sql_mode */ ;
/*!50003 SET character_set_client  = @saved_cs_client */ ;
/*!50003 SET character_set_results = @saved_cs_results */ ;
/*!50003 SET collation_connection  = @saved_col_connection */ ;
/*!50003 DROP PROCEDURE IF EXISTS `formatPK` */;
/*!50003 SET @saved_cs_client      = @@character_set_client */ ;
/*!50003 SET @saved_cs_results     = @@character_set_results */ ;
/*!50003 SET @saved_col_connection = @@collation_connection */ ;
/*!50003 SET character_set_client  = utf8 */ ;
/*!50003 SET character_set_results = utf8 */ ;
/*!50003 SET collation_connection  = utf8_general_ci */ ;
/*!50003 SET @saved_sql_mode       = @@sql_mode */ ;
/*!50003 SET sql_mode              = 'STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION' */ ;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `formatPK`()
begin
	declare done int default 0;
	declare _id varchar(20);
	declare cur cursor for select id from selection;
	declare continue handler for not found set done=1;
	open cur;
	cursor_loop: loop
		fetch cur into _id;
		if done=1 then
			leave cursor_loop;
		end if;
		update selection set id=no_zero(_id,'-') where id=_id;
		update options,selection set pk=no_zero(pk,'-') where options.id=selection.id;
	end loop cursor_loop;
	close cur;
end ;;
DELIMITER ;
/*!50003 SET sql_mode              = @saved_sql_mode */ ;
/*!50003 SET character_set_client  = @saved_cs_client */ ;
/*!50003 SET character_set_results = @saved_cs_results */ ;
/*!50003 SET collation_connection  = @saved_col_connection */ ;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-12-11 10:08:47
